# Pseudocodes

You can check the pseudocodes that generated by IDA and cleaned up as good as Im able to.

## _PAGEWX_PREPARATION_INFO

```c
struct _PAGEWX_PREPARATION_INFO
{
  DWORD64 NewMdlVa;
  DWORD64 NewMdlLength;
  DWORD64 MdlVaToMappingOffset;
  DWORD IsEncrypt;
  DWORD Unknown5;
  DWORD64 PAGEwxN;
  DWORD64 NewMdl;
  DWORD64 Mdl;
  DWORD IsNewMdlLocked;
  DWORD Unknown9;
  DWORD64 MdlVaOrSectionVa;
  DWORD64 LockedMappedMdlVa;
  DWORD64 MdlLength;
  DWORD64 PAGEwxIndex;
};
```

## WarbirdDecryptSection

```c
__int64 __fastcall WarbirdDecryptSection(unsigned int *DecryptionData1, int *DecryptionData2)
{
  int result; // edi
  int decryptionCount; // eax

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 )
  {
    if ( decryptionCount != -1 )
      *DecryptionData2 = decryptionCount + 1;
  }
  else
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 0);
    if ( result >= 0 )
      *DecryptionData2 = 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return (unsigned int)result;
}
```

## WarbirdReencryptSection

```c
__int64 __fastcall WarbirdReencryptSection(_DWORD *DecryptionData1, int *DecryptionData2)
{
  int decryptionCount; // ecx
  unsigned int result; // eax MAPDST

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 == 1 )
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 1u);
    *DecryptionData2 = 0;
  }
  else if ( (unsigned int)(decryptionCount - 1) <= 0xFFFFFFFD )
  {
    *DecryptionData2 = decryptionCount - 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return result;
}
```

## WarbirdEncryptDecryptSection

```c
__int64 __fastcall WarbirdEncryptDecryptSection(__int64 DecryptionData1, __int64 DecryptionData2, DWORD IsEncrypt)
{
  int result; // esi
  unsigned int i; // r14d
  unsigned __int64 NewMdlVaLength2; // r8
  DWORD64 NewMdlVa; // rbx
  DWORD64 NewMdlVaEnd; // r13
  unsigned __int64 v10; // r9
  unsigned int v11; // edx
  _PAGEWX_PREPARATION_INFO SectionInfo; // [rsp+40h] [rbp-39h] BYREF
  unsigned int NewMdlVaLength; // [rsp+E0h] [rbp+67h] BYREF

  SectionInfo.PAGEwxN = (unsigned __int8)((unsigned __int64)*(unsigned int *)DecryptionData1 >> 1);
  memset(&SectionInfo, 0, 24);
  result = 0;
  SectionInfo.IsEncrypt = IsEncrypt;
  memset(&SectionInfo.NewMdl, 0, 20);
  memset(&SectionInfo.MdlVaOrSectionVa, 0, 32);
  if ( !(unsigned int)WarbirdPrepareSectionForModification(&SectionInfo) )
    return 0x80070005LL;
  i = 0;
  if ( *(_WORD *)(DecryptionData1 + 80) )
  {
    do
    {
      if ( result < 0 )
        break;
      NewMdlVa = 0x180000000LL + ((*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF);
      NewMdlVaLength = *(_DWORD *)(DecryptionData1 + 8LL * i + 88) & 0xFFFFFFF;
      NewMdlVaLength2 = NewMdlVaLength;
      NewMdlVaEnd = NewMdlVa + NewMdlVaLength;
      if ( NewMdlVa < SectionInfo.NewMdlVa || NewMdlVaEnd >= SectionInfo.NewMdlLength + SectionInfo.NewMdlVa )
      {
        WarbirdCleanUpMdl(&SectionInfo);
        SectionInfo.NewMdlVa = NewMdlVa & 0xFFFFFFFFFFFFF000uLL;
        SectionInfo.NewMdlLength = ((NewMdlVaEnd + 4095) & 0xFFFFFFFFFFFFF000uLL) - (NewMdlVa & 0xFFFFFFFFFFFFF000uLL);
        if ( !(unsigned int)WarbirdSetupNewMdl(&SectionInfo) )
          goto LABEL_19;
        NewMdlVaLength2 = NewMdlVaLength;
      }
      if ( NewMdlVa + SectionInfo.MdlVaToMappingOffset )
      {
        v10 = *(_QWORD *)(DecryptionData1 + 8);
        v11 = *(unsigned __int16 *)(DecryptionData2 + 2LL * i + 4);
        if ( IsEncrypt )
        {
          if ( (v11 & 0x8000u) == 0 )
          {
            LOBYTE(NewMdlVaLength) = 0;
            WarbirdFeistelEncrypt(
              (char *)NewMdlVa,
              (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
              NewMdlVaLength2,
              v10,
              (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
              &NewMdlVaLength);
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4) = NewMdlVaLength;
            *(_WORD *)(DecryptionData2 + 2LL * i + 4) |= 0x8000u;
          }
        }
        else if ( (v11 & 0x8000) != 0 )
        {
          LOWORD(v11) = ~(_WORD)v11;
          WarbirdFeistelDecrypt(
            (_BYTE *)NewMdlVa,
            (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
            NewMdlVaLength2,
            v10,
            (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4),
            (v11 >> 8) & 1);
          *(_WORD *)(DecryptionData2 + 2LL * i + 4) = *(_WORD *)(DecryptionData2 + 2LL * i + 4) & 0x7EFF | 0x100;
        }
        goto LABEL_10;
      }
LABEL_19:
      result = 0x8007000E;
LABEL_10:
      ++i;
    }
    while ( i < (unsigned __int16)*(_DWORD *)(DecryptionData1 + 80) );
  }
  WarbirdCleanUpMdl(&SectionInfo);
  if ( !WarbirdFinishSectionModification(&SectionInfo) )
    return 0x8007000E;
  return (unsigned int)result;
}
```

## WarbirdPrepareSectionForModification

```c
__int64 __fastcall WarbirdPrepareSectionForModification(_PAGEWX_PREPARATION_INFO *pSectionInfo)
{
  __int64 PAGEwxIndex; // r8
  unsigned int *PAGEwxN; // r9
  void *pTargetRVA; // rcx
  DWORD64 TargetLength; // rax
  struct _MDL *pTargetMdl; // rax
  PMDL *ppSectionMdl; // rsi
  PVOID LockedDataSectionHandle; // r14
  PMDL pMdl; // r10
  PVOID MappedSystemVa; // rax
  DWORD64 *p_Mdl; // rdi
  unsigned int IsSucceed; // [rsp+30h] [rbp-28h]

  IsSucceed = 1;
  PAGEwxIndex = 0;
  PAGEwxN = &StoredPAGEwxData[0].PAGEwxN;
  do
  {
    if ( *PAGEwxN == pSectionInfo->PAGEwxN )
      break;
    PAGEwxIndex = (unsigned int)(PAGEwxIndex + 1);
    PAGEwxN += 5;
  }
  while ( (unsigned int)PAGEwxIndex < 6 );
  if ( (_DWORD)PAGEwxIndex != 6 )
  {
    pSectionInfo->PAGEwxIndex = (unsigned int)PAGEwxIndex;
    pTargetRVA = (void *)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA);
    pSectionInfo->MdlVaOrSectionVa = (DWORD64)pTargetRVA;
    TargetLength = StoredPAGEwxData[PAGEwxIndex].PageCount << 12;
    pSectionInfo->MdlLength = TargetLength;
    pTargetMdl = IoAllocateMdl(pTargetRVA, TargetLength, 0, 0, 0);
    ppSectionMdl = (PMDL *)&pSectionInfo->Mdl;
    pSectionInfo->Mdl = (DWORD64)pTargetMdl;
    if ( pTargetMdl )
    {
      MmProbeAndLockPages(pTargetMdl, 0, IoModifyAccess);
      if ( (int)MmChangeImageProtection(
                  *ppSectionMdl,
                  (unsigned int)PAGEwxHashRVA
                + 32LL * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].HashIndex
                + 0x180000020LL,
                  32 * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].PageCount,
                  2) < 0 )
      {
        MmUnlockPages(*ppSectionMdl);
        IsSucceed = 0;
      }
      else
      {
        LockedDataSectionHandle = 0;
        if ( !pSectionInfo->IsEncrypt )
        {
          LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL
                                                                   + StoredPAGEwxData[pSectionInfo->PAGEwxIndex].RVA));
          ++LockedPagableDataSectionCount;
        }
        pMdl = *ppSectionMdl;
        if ( ((*ppSectionMdl)->MdlFlags & 5) != 0 )
          MappedSystemVa = pMdl->MappedSystemVa;
        else
          MappedSystemVa = MmMapLockedPagesSpecifyCache(pMdl, 0, MmCached, 0, 0, 0x40000020u);
        pSectionInfo->LockedMappedMdlVa = (DWORD64)MappedSystemVa;
        if ( !MappedSystemVa )                  // If failed
        {
          if ( !pSectionInfo->IsEncrypt && LockedDataSectionHandle )
          {
            MmUnlockPagableImageSection(LockedDataSectionHandle);
            ++UnlockedPagableImageSectionCount;
          }
          WarbirdChangeImageProtection(pSectionInfo, 0);
          MmUnlockPages(*ppSectionMdl);
          IsSucceed = 0;
          ++qword_1800DAEB8;
        }
      }
      if ( IsSucceed )
        return IsSucceed;
      p_Mdl = &pSectionInfo->Mdl;
    }
    else
    {
      IsSucceed = 0;
      p_Mdl = &pSectionInfo->Mdl;
    }
    if ( *ppSectionMdl )
    {
      IoFreeMdl(*ppSectionMdl);
      *p_Mdl = 0;
    }
    return IsSucceed;
  }
  return 1;
}
```

## WarbirdFinishSectionModification

```c
_BOOL8 __fastcall WarbirdFinishSectionModification(_PAGEWX_PREPARATION_INFO *pPagesInfo)
{
  struct _MDL *pSectionMdl; // rdx
  BOOL IsSucceed; // ebp
  DWORD64 PAGEwxIndex; // rax
  PVOID LockedDataSectionHandle; // rax MAPDST
  _BOOL8 result; // rax
  __int64 HashRVA; // r14
  unsigned int PageCount; // ebx
  __int64 HashIndex; // r15
  void *LockedMappedMdlVa; // rcx

  pSectionMdl = (struct _MDL *)pPagesInfo->Mdl;
  IsSucceed = 1;
  if ( pSectionMdl )
  {
    PAGEwxIndex = pPagesInfo->PAGEwxIndex;
    if ( pPagesInfo->IsEncrypt )
    {
      LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA));
      ++LockedPagableDataSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
    }
    else
    {
      HashRVA = (unsigned int)PAGEwxHashRVA;
      PageCount = StoredPAGEwxData[PAGEwxIndex].PageCount;
      HashIndex = StoredPAGEwxData[PAGEwxIndex].HashIndex;
      LockedMappedMdlVa = (void *)pPagesInfo->LockedMappedMdlVa;
      if ( LockedMappedMdlVa )
      {
        MmUnmapLockedPages(LockedMappedMdlVa, pSectionMdl);
        pPagesInfo->LockedMappedMdlVa = 0;
      }
      IsSucceed = (int)MmChangeImageProtection(
                         pPagesInfo->Mdl,
                         HashRVA + 32 * HashIndex + 0x180000020LL,
                         32 * PageCount,
                         1) >= 0;
    }
    MmUnlockPages((PMDL)pPagesInfo->Mdl);
    IoFreeMdl((PMDL)pPagesInfo->Mdl);
    pPagesInfo->Mdl = 0;
  }
  pPagesInfo->MdlVaOrSectionVa = 0;
  result = IsSucceed;
  pPagesInfo->LockedMappedMdlVa = 0;
  pPagesInfo->MdlLength = 0;
  pPagesInfo->PAGEwxIndex = 0;
  pPagesInfo->MdlVaToMappingOffset = 0;
  return result;
}
```

## MmChangeImageProtection

```c
__int64 __fastcall MmChangeImageProtection(
        _MDL *pTargetMdl,
        unsigned __int64 pHash,
        __int64 HashSize,
        int ProtectionFlags)
{
  int HashSize2; // r13d
  ULONG TargetMdlByteCount; // ebp
  unsigned int TargetMdlPageCount; // ebp
  _KLDR_DATA_TABLE_ENTRY *pModuleTableEntry; // rax MAPDST
  int output; // ebx
  char *TargetModuleBase; // r8
  unsigned __int64 pHashEnd; // rdx
  char *TargetModuleEnd; // rax
  unsigned int Flags; // eax
  unsigned __int64 *pTargetMdlPfnArray; // r15
  __int64 i; // r14
  _MMPFN *pCurrentPfnDatabaseEntry; // rcx
  unsigned int v21; // r9d
  __int64 v22; // rdi
  _DWORD IsLdrTableLocked[14]; // [rsp+20h] [rbp-38h] BYREF

  IsLdrTableLocked[0] = 0;
  if ( (unsigned int)(ProtectionFlags - 1) > 1 )// Only accepts ProtectionFlag either 1 or 2
    return 0xC000000DLL;
  HashSize2 = HashSize;
  if ( HashSize != (unsigned int)HashSize )
    return 0xC000000DLL;
  if ( (pTargetMdl->MdlFlags & 7) != 2 )
    return 0xC000000DLL;
  if ( pTargetMdl->ByteOffset )
    return 0xC000000DLL;
  TargetMdlByteCount = pTargetMdl->ByteCount;
  if ( (TargetMdlByteCount & 0xFFF) != 0 )
    return 0xC000000DLL;
  TargetMdlPageCount = TargetMdlByteCount >> 0xC;
  pModuleTableEntry = (_KLDR_DATA_TABLE_ENTRY *)MiLockLoadedDataTableEntryIfNecessary(
                                                  (__int64)pTargetMdl->StartVa,
                                                  IsLdrTableLocked);
  if ( pModuleTableEntry )
  {
    TargetModuleBase = (char *)pModuleTableEntry->DllBase;
    pHashEnd = pHash + HashSize;
    TargetModuleEnd = &TargetModuleBase[pModuleTableEntry->SizeOfImage];
    if ( (char *)pTargetMdl->StartVa + pTargetMdl->ByteCount > TargetModuleEnd
      || pHash < (unsigned __int64)TargetModuleBase
      || pHashEnd > (unsigned __int64)TargetModuleEnd
      || pHashEnd - 1 < pHash )
    {
      output = 0xC0000018;
    }
    else
    {
      Flags = pModuleTableEntry->Flags;
      if ( (Flags & 0x80000) != 0 )
      {
        output = 0xC0000043;
      }
      else
      {
        output = 0;
        pModuleTableEntry->Flags = Flags | 0x80000;
        if ( (unsigned int)MI_IS_PHYSICAL_ADDRESS((unsigned __int64)TargetModuleBase) )
        {
LABEL_34:
          output = 0xC0000018;
        }
        else
        {
          pTargetMdlPfnArray = (unsigned __int64 *)&pTargetMdl[1];
          for ( i = 0; (unsigned int)i < TargetMdlPageCount; i = (unsigned int)(i + 1) )
          {
            pCurrentPfnDatabaseEntry = (_MMPFN *)(0x30 * pTargetMdlPfnArray[i] - 0x220000000000LL);// Get PFN database (MMPFN)
            if ( (pCurrentPfnDatabaseEntry->u4.EntireField & 0x8000000000000000uLL) != 0LL )// Checks if PrototypePte flag is set.
              goto LABEL_34;
            if ( (MiGetPagePrivilege((ULONG_PTR)pCurrentPfnDatabaseEntry) & 0x40) != 0 )
            {
              output = 0xC0000045;
              goto LABEL_24;
            }
          }
          MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, 1u);// Protection set to writable
          if ( ProtectionFlags == 1 )
          {
            if ( (MiFlags & 0x4000) == 0
              || (output = VslValidateDynamicCodePages((__int64)pTargetMdl, pHash, HashSize2), output >= 0) )
            {
              v21 = 3;
              if ( (MiFlags & 0x8000) != 0 && output == 0x12C )
                v21 = 0x13;
              MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, v21);// Protection set to executable
              output = 0;
            }
          }
          else if ( (MiFlags & 0x8000) != 0 && TargetMdlPageCount )
          {
            v22 = TargetMdlPageCount;
            do
            {
              MiClearPfnImageVerified(0x30 * *pTargetMdlPfnArray++ - 0x220000000000LL, 9);
              --v22;
            }
            while ( v22 );
          }
        }
LABEL_24:
        pModuleTableEntry->Flags &= ~0x80000u;
      }
    }
    if ( IsLdrTableLocked[0] )
      MmUnlockLoadedDataTableEntry(pModuleTableEntry);
  }
  else
  {
    return 0xC0000225;
  }
  return (unsigned int)output;
}
```

## VslValidatesDynamicCodePages

```c
__int64 __fastcall VslValidateDynamicCodePages(_MDL *pTargetMdl, unsigned __int64 pHash, unsigned int HashSize)
{
  SIZE_T SizeOfTargetMdl; // rax
  unsigned __int64 TargetMdlPageCount; // rdx
  int result; // ebx
  _VSLP_TRANSFER_STRUCTURE HashTransferData; // [rsp+30h] [rbp-118h] BYREF
  _SSCN_20H_SKCALL SKCALLPacket; // [rsp+80h] [rbp-C8h] BYREF
  struct _MDL TargetMdlLvl2; // [rsp+F0h] [rbp-58h] BYREF
  unsigned __int64 TargetMdlLvl2Pfn; // [rsp+120h] [rbp-28h]

  memset_0(&SKCALLPacket, 0, sizeof(SKCALLPacket));
  memset(&TargetMdlLvl2.MdlFlags + 1, 0, 0x14);
  TargetMdlLvl2Pfn = 0;
  memset_0(&HashTransferData, 0, sizeof(HashTransferData));
  SizeOfTargetMdl = MmSizeOfMdl(pTargetMdl->StartVa, pTargetMdl->ByteCount + pTargetMdl->ByteOffset);
  TargetMdlPageCount = (SizeOfTargetMdl + ((unsigned __int16)pTargetMdl & 0xFFF) + 0xFFFLL) >> 0xC;
  if ( TargetMdlPageCount > 1 )
    return 0xC000000DLL;
  TargetMdlLvl2.Next = 0;
  TargetMdlLvl2.Size = 8 * (TargetMdlPageCount + 6);
  TargetMdlLvl2.MdlFlags = 0;
  TargetMdlLvl2.StartVa = (PVOID)((unsigned __int64)pTargetMdl & 0xFFFFFFFFFFFFF000uLL);
  TargetMdlLvl2.ByteOffset = (unsigned __int16)pTargetMdl & 0xFFF;
  TargetMdlLvl2.ByteCount = SizeOfTargetMdl;
  MmProbeAndLockPages(&TargetMdlLvl2, 0, IoReadAccess);
  result = VslpLockPagesForTransfer(&HashTransferData, pHash, HashSize, IoReadAccess, 0);
  if ( result >= 0 )
  {
    SKCALLPacket.pTargetMdl = pTargetMdl;
    SKCALLPacket.TargetMdlLvl2Pfn = TargetMdlLvl2Pfn;
    SKCALLPacket.pHashMdlLvl1 = HashTransferData.pFirstLevelMdl;
    SKCALLPacket.HashMdlLvl2Pfn = HashTransferData.SecondLevelMdlPfn;
    result = VslpEnterIumSecureMode(2u, 0x20u, 0, (__int64)&SKCALLPacket);// 2 = Invoke Secure Service
                                                // 0x20 = SSCN
    VslpUnlockPagesForTransfer(&HashTransferData);
  }
  MmUnlockPages(&TargetMdlLvl2);
  return (unsigned int)result;
}
```

## _VSLP_TRANSFER_STRUCTURE

```c
struct _VSLP_TRANSFER_STRUCTURE
{
  _MDL *pFirstLevelMdl;
  _MDL SecondLevelMdl;
  unsigned __int64 SecondLevelMdlPfn;
  unsigned int Flags;
};
```

## _SSCN_20H_PACKET

```c
struct _SSCN_20H_SKCALL
{
  BYTE Unknown1;
  BYTE Unknown2;
  WORD SSCN;
  DWORD Unknown3;
  _MDL *pTargetMdl;
  unsigned __int64 TargetMdlLvl2Pfn;
  _MDL *pHashMdlLvl1;
  unsigned __int64 HashMdlLvl2Pfn;
  BYTE UnknownData[64];
};
```

## IumInvokeSecureService case 0x20

```c
      case 0x20:
          HashMdlLvl2Pfn = *((_QWORD *)SKCALLPacket + 4);
          pHashMdl = (_MDL *)*((_QWORD *)SKCALLPacket + 3);
          TargetMdlLvl2Pfn = *((_QWORD *)SKCALLPacket + 2);
          pTargetMdl = (_MDL *)*((_QWORD *)SKCALLPacket + 1);
          memset(&SSCN_20H_Params, 0, sizeof(SSCN_20H_Params));
          if ( (SkmiFlags & 0x10) == 0 )
            goto LABEL_377;
          result = SkmmMapDataTransfer(
                     pHashMdl,
                     HashMdlLvl2Pfn,
                     0x80000001,
                     &SSCN_20H_Params.pCopiedHashMdl,
                     &SSCN_20H_Params.HashMdlStartVa);// Maps the hash to VTL1
          if ( result < 0 )
            goto LABEL_377;
          if ( SSCN_20H_Params.pCopiedHashMdl->ByteCount )
          {
            SSCN_20H_Params.pTargetMdl = pTargetMdl;
            SSCN_20H_Params.TargetMdlLvl2Pfn = TargetMdlLvl2Pfn;
            result = SkmiOperateOnLockedNar(
                       SSCN_20H_Params.HashMdlStartVa,
                       (__int64 (__fastcall *)(_QWORD *, __int64))SkmiValidateDynamicCodePages,
                       (__int64)&SSCN_20H_Params);
          }
          else
          {
            result = 0xC000000D;
          }
          SkmmUnmapDataTransfer(SSCN_20H_Params.pCopiedHashMdl);
          goto LABEL_1227;
```

## SkmiOperateOnLockedNar

```c
__int64 __fastcall SkmiOperateOnLockedNar(
        unsigned __int64 pDataStartVa,
        __int64 (__fastcall *pTargetFunction)(_QWORD *, __int64),
        __int64 pFunctionParams)
{
  _QWORD *StackBase; // rax MAPDST
  _QWORD *NarTreeEntry; // rcx
  unsigned __int64 NarEntryBase; // rdx
  unsigned int status; // ebx
  signed __int64 PreviousLockValue; // rax
  __int64 v12; // rdx
  __int64 v14; // rcx
  signed __int64 v15; // rdx
  signed __int64 v16; // rtt
  bool v17; // zf
  signed __int64 v18; // rax
  _QWORD *v19; // r9
  __int64 v20; // r8
  _QWORD *v21; // rax
  __int64 v22; // rax
  __int64 v23; // rcx
  signed __int64 v24; // rax
  __int64 v25; // rdi
  __int64 v26; // rcx

  StackBase = KeGetPcr()->NtTib.StackBase;
  if ( StackBase )
  {
    v23 = StackBase[0x12];
    if ( v23 )
      --*(_WORD *)(v23 + qword_14013B160);
  }
  if ( _interlockedbittestandset64((volatile signed __int32 *)&SkmiNarLock, 0) )// Lock SkmiNarLock
    RtlpAcquireSRWLockExclusiveContended(&SkmiNarLock, (__int64)pTargetFunction);
  NarTreeEntry = (_QWORD *)SkmiNarTree;
  if ( !SkmiNarTree )
  {
LABEL_9:
    status = 0xC0000018;
    goto LABEL_10;
  }
  while ( 1 )
  {
    NarEntryBase = NarTreeEntry[3];
    if ( pDataStartVa >= NarEntryBase )         // Find a NAR that corresponds to the data.
      break;
    NarTreeEntry = (_QWORD *)*NarTreeEntry;     // Iterate through the NAR entries based on the data address
LABEL_7:
    if ( !NarTreeEntry )
      goto LABEL_8;
  }
  if ( pDataStartVa > NarEntryBase + (NarTreeEntry[0xA] << 0xC) - 1LL )
  {
    NarTreeEntry = (_QWORD *)NarTreeEntry[1];
    goto LABEL_7;
  }
LABEL_8:
  if ( !NarTreeEntry )
    goto LABEL_9;
  status = pTargetFunction(NarTreeEntry, pFunctionParams);
LABEL_10:
  PreviousLockValue = _InterlockedCompareExchange64(&SkmiNarLock, 0, 1);
  if ( PreviousLockValue != 1 )
  {
    do
    {
      if ( (PreviousLockValue & 4) != 0 || (v14 = 3, (PreviousLockValue & 2) == 0) )
        v14 = 0xFFFFFFFFFFFFFFFFuLL;
      v15 = v14 + PreviousLockValue;
      v16 = PreviousLockValue;
      PreviousLockValue = _InterlockedCompareExchange64(&SkmiNarLock, v14 + PreviousLockValue, PreviousLockValue);
    }
    while ( v16 != PreviousLockValue );
    if ( v14 == 3 )
    {
      while ( 1 )
      {
        while ( (v15 & 1) != 0 )
        {
          v18 = _InterlockedCompareExchange64(&SkmiNarLock, v15 - 4, v15);
          v17 = v15 == v18;
          v15 = v18;
          if ( v17 )
            goto LABEL_11;
        }
        v19 = (_QWORD *)(v15 & 0xFFFFFFFFFFFFFFF0uLL);
        v20 = *(_QWORD *)((v15 & 0xFFFFFFFFFFFFFFF0uLL) + 8);
        if ( !v20 )
        {
          do
          {
            v21 = v19;
            v19 = (_QWORD *)*v19;
            v19[2] = v21;
            v20 = v19[1];
          }
          while ( !v20 );
          if ( v19 != (_QWORD *)(v15 & 0xFFFFFFFFFFFFFFF0uLL) )
            *(_QWORD *)((v15 & 0xFFFFFFFFFFFFFFF0uLL) + 8) = v20;
        }
        if ( (*(_DWORD *)(v20 + 0x24) & 1) != 0 )
        {
          v22 = *(_QWORD *)(v20 + 0x10);
          if ( v22 )
            break;
        }
        v24 = _InterlockedCompareExchange64(&SkmiNarLock, 0, v15);
        v17 = v15 == v24;
        v15 = v24;
        if ( v17 )
          goto LABEL_36;
      }
      *(_QWORD *)((v15 & 0xFFFFFFFFFFFFFFF0uLL) + 8) = v22;
      *(_QWORD *)(v20 + 0x10) = 0;
      _InterlockedAnd64(&SkmiNarLock, 0xFFFFFFFFFFFFFFFBuLL);
      do
      {
LABEL_36:
        v25 = *(_QWORD *)(v20 + 0x10);
        v26 = *(_QWORD *)(v20 + 0x18);
        _interlockedbittestandset((volatile signed __int32 *)(v20 + 0x24), 2u);
        if ( !_interlockedbittestandreset((volatile signed __int32 *)(v20 + 0x24), 1u) )
          SkeAlertThreadByThreadId(v26);
        v20 = v25;
      }
      while ( v25 );
    }
  }
LABEL_11:
  StackBase = KeGetPcr()->NtTib.StackBase;
  if ( StackBase )
  {
    v12 = StackBase[0x12];
    if ( v12 )
    {
      v17 = (*(_WORD *)(qword_14013B160 + v12))++ == 0xFFFF;
      if ( v17
        && *(_QWORD *)(qword_14013B170 + v12) != qword_14013B170 + StackBase[0x11]
        && !*(_WORD *)(qword_14013B168 + v12) )
      {
        SkiCheckForKernelApcDelivery();
      }
    }
  }
  return status;
}
```

## SkmiValidateDynamicCodePages

```c
__int64 __fastcall SkmiValidateDynamicCodePages(__int64 pNarTreeEntry, _SkmiValidateDynamicCodePages_Params *pParams)
{
  __int16 v2; // r8
  int HashMdlStartVa; // ecx
  unsigned int HashStartVaToNarBaseOffset; // r12d
  __int64 HashByteCount; // r8
  ULONG_PTR TargetMdlLvl2Pfn; // rdx
  __int64 HashMdlRounding; // r14
  _MDL *pTargetMdl; // rcx
  unsigned __int64 HashPageCount; // r14
  __int64 result; // rax
  ULONG TargetMdlByteCount; // r13d
  unsigned __int64 NarRangeBase; // rdx
  unsigned int TargetMdlPageCount; // r13d MAPDST
  unsigned __int64 TargetMdlStartVaAndNarRangeBasePageDistance; // rcx
  int result2; // eax
  int result4; // esi
  signed __int64 *pPteOfTargetCode; // rdi
  unsigned __int64 *pCurrentCopiedTargetMdlPfn; // rbx
  __int64 TargetMdlPageCount2; // r15
  __int64 v23; // rax
  __int64 CurrentPageIndex; // r15
  unsigned int HashStartVaAndNarBasePageDistance; // r12d
  ULONG v26; // edx
  unsigned int i; // ebx
  __int64 pCurrentPdeOfHashData; // rdx
  unsigned __int64 *pCurrentPteOfHashData; // rdx
  unsigned __int64 CurrentPteOfHashData; // rax
  _MDL *pCopiedHashMdl2; // r8
  int v33; // eax
  __int64 v34; // r8
  const signed __int64 **PteTrace; // rax
  PVOID *v36; // r15
  ULONG v37; // ecx
  int v38; // ecx
  int v39; // ecx
  char *v40; // r15
  __int64 v41; // r14
  const signed __int64 *v42; // rbx
  __int64 v43; // r8
  const signed __int64 **v44; // rax
  PVOID *v45; // r12
  ULONG v46; // ecx
  __int64 *v47; // rax
  __int64 *v48; // rbx
  char *v49; // rsi
  __int64 v50; // r12
  const signed __int64 *v51; // rbx
  __int64 v52; // r8
  const signed __int64 **v53; // rax
  const signed __int64 **v54; // r15
  PVOID *v55; // r14
  ULONG v56; // ecx
  __int64 v57; // rcx
  int v58; // ecx
  __int64 *Pool; // [rsp+30h] [rbp-69h]
  int v60; // [rsp+38h] [rbp-61h]
  _MDL *pCopiedHashMdl; // [rsp+40h] [rbp-59h]
  _MDL *pCopiedTargetMdl; // [rsp+48h] [rbp-51h] BYREF
  ULONG BackTraceHash; // [rsp+50h] [rbp-49h] BYREF
  unsigned __int64 HashMdlStartVa2; // [rsp+58h] [rbp-41h] MAPDST
  unsigned __int64 *pCopiedTargetMdlPfnArray; // [rsp+60h] [rbp-39h]
  unsigned __int64 TargetMdlStartVa; // [rsp+68h] [rbp-31h] MAPDST BYREF
  unsigned __int64 pPteOfHashData; // [rsp+70h] [rbp-29h]
  unsigned __int64 v69; // [rsp+78h] [rbp-21h] BYREF
  __int64 v70; // [rsp+80h] [rbp-19h]
  const signed __int64 **v71; // [rsp+88h] [rbp-11h]
  signed __int64 *v72; // [rsp+90h] [rbp-9h]
  unsigned __int64 HashPageCount2; // [rsp+98h] [rbp-1h]
  unsigned __int64 v74[2]; // [rsp+A0h] [rbp+7h] BYREF
  const signed __int64 *retaddr; // [rsp+F8h] [rbp+5Fh]
  const signed __int64 **v78; // [rsp+110h] [rbp+77h]
  int result3; // [rsp+118h] [rbp+7Fh]

  v2 = *(_WORD *)(pNarTreeEntry + 0x5E);
  v69 = 0;
  pCopiedTargetMdl = 0;
  TargetMdlStartVa = 0;
  v60 = 0;
  *(_OWORD *)v74 = 0;
  if ( (v2 & 6) != 2 || (v2 & 8) != 0 )
  {
    v58 = 0x39;
    goto LABEL_96;
  }
  HashMdlStartVa = pParams->HashMdlStartVa;
  HashStartVaToNarBaseOffset = HashMdlStartVa - *(_DWORD *)(pNarTreeEntry + 0x18);
  pCopiedHashMdl = pParams->pCopiedHashMdl;
  HashByteCount = pParams->pCopiedHashMdl->ByteCount;
  if ( (unsigned int)HashByteCount + HashStartVaToNarBaseOffset <= HashStartVaToNarBaseOffset
    || (unsigned int)HashByteCount + HashStartVaToNarBaseOffset > *(_DWORD *)(pNarTreeEntry + 0x58) << 0xC )// Checks if the hash data is outside the boundary of the NAR entry
  {
    v58 = 0x1D;
LABEL_96:
    SKMI_SECURITY(v58);
    return 0xC0000018LL;
  }
  TargetMdlLvl2Pfn = pParams->TargetMdlLvl2Pfn;
  HashMdlRounding = (HashMdlStartVa & 0xFFF) + 0xFFFLL;
  pTargetMdl = pParams->pTargetMdl;
  HashPageCount = (unsigned __int64)(HashByteCount + HashMdlRounding) >> 0xC;
  HashPageCount2 = HashPageCount;
  result = SkmmMapDataTransfer(pTargetMdl, TargetMdlLvl2Pfn, 0x80000001, &pCopiedTargetMdl, &TargetMdlStartVa);// Maps the target memory to VTL1
  if ( (int)result < 0 )
    return result;
  if ( (TargetMdlStartVa & 0xFFF) != 0
    || (TargetMdlByteCount = pCopiedTargetMdl->ByteCount, (TargetMdlByteCount & 0xFFF) != 0) )// Make sure the target VA and size is page aligned
  {
    result4 = 0xC000000D;
    goto LABEL_91;
  }
  NarRangeBase = *(_QWORD *)(pNarTreeEntry + 0x18);
  TargetMdlPageCount = TargetMdlByteCount >> 0xC;
  pCopiedTargetMdlPfnArray = pCopiedTargetMdl->Pfns;
  if ( TargetMdlStartVa < NarRangeBase
    || (TargetMdlStartVaAndNarRangeBasePageDistance = TargetMdlPageCount + ((TargetMdlStartVa - NarRangeBase) >> 0xC),
        TargetMdlStartVaAndNarRangeBasePageDistance > *(unsigned int *)(pNarTreeEntry + 0x58)) )// *(unsigned int *)(pNarTreeEntry + 0x58)) = NAR page count
  {
    SKMI_SECURITY(0x3A);
    result4 = 0xC0000018;
    goto LABEL_91;
  }
  result2 = SkmiLockDriverNtAddresses(TargetMdlStartVaAndNarRangeBasePageDistance, TargetMdlStartVa, TargetMdlPageCount);
  result3 = result2;
  result4 = result2;
  if ( result2 < 0 )
  {
    if ( result2 == 0xC0000018 )
      SKMI_SECURITY(0x18);
    goto LABEL_91;
  }
  pPteOfTargetCode = (signed __int64 *)(((TargetMdlStartVa >> 9) & 0x7FFFFFFFF8LL) - 0xA0000000000LL);
  if ( TargetMdlPageCount )
  {
    pCurrentCopiedTargetMdlPfn = pCopiedTargetMdlPfnArray;
    TargetMdlPageCount2 = TargetMdlPageCount;
    do
    {
      SkmiClaimPhysicalPage(*pCurrentCopiedTargetMdlPfn++, 5u);
      --TargetMdlPageCount2;
    }
    while ( TargetMdlPageCount2 );
  }
  v23 = *(_QWORD *)(pNarTreeEntry + 0x38);
  CurrentPageIndex = 0;
  if ( v23 )
  {
    HashStartVaAndNarBasePageDistance = HashStartVaToNarBaseOffset >> 0xC;
    v70 = *(_QWORD *)(v23 + 8) + 8LL * HashStartVaAndNarBasePageDistance;
  }
  else
  {
    HashStartVaAndNarBasePageDistance = 0;
    v70 = 0;
  }
  pPteOfHashData = ((pParams->HashMdlStartVa >> 9) & 0x7FFFFFFFF8LL) - 0xA0000000000LL;
  if ( (unsigned int)HashPageCount <= 2 )
  {
    Pool = (__int64 *)v74;
  }
  else
  {
    v60 = HashPageCount;
    Pool = (__int64 *)SkAllocatePool(0x200, 8LL * (unsigned int)HashPageCount);
    if ( !Pool )
    {
      result4 = 0xC000009A;
      result3 = 0xC000009A;
      goto LABEL_78;
    }
    CurrentPageIndex = 0;
  }
  HashMdlStartVa2 = pParams->HashMdlStartVa;
  LOBYTE(v78) = SkAcquireSpinLockShared((__int64)&SkmiNteLock);
  for ( i = 0; i < (unsigned int)HashPageCount; ++i )
  {
    if ( !i || (CurrentPageIndex = i, (((_WORD)pPteOfHashData + 8 * (_WORD)i) & 0xFF8) == 0) )
    {
      pCurrentPdeOfHashData = *(_QWORD *)((((pPteOfHashData + 8 * CurrentPageIndex) >> 9) & 0x7FFFFFFFF8LL)
                                        - 0x98000000000LL);
      if ( (pCurrentPdeOfHashData & 1) == 0 || (pCurrentPdeOfHashData & 0x80u) != 0LL )// Check if PDE is present and is not large page (2MB), make sures it have individual PTEs
      {
        v39 = 0x20;
        goto LABEL_56;
      }
    }
    pCurrentPteOfHashData = (unsigned __int64 *)(pPteOfHashData + 8 * CurrentPageIndex);
    CurrentPteOfHashData = *pCurrentPteOfHashData;
    if ( (*pCurrentPteOfHashData & 0x200) == 0 )
    {
      v39 = 0x22;
LABEL_56:
      SKMI_SECURITY(v39);
      result4 = 0xC0000005;
      result3 = 0xC0000005;
      goto LABEL_57;
    }
    if ( (*pCurrentPteOfHashData & 0x801) != 1 && (CurrentPteOfHashData & 0x100) == 0 )
    {
      pCopiedHashMdl2 = pCopiedHashMdl;
LABEL_38:
      if ( !v70 )
      {
        v38 = 0x3B;
        goto LABEL_52;
      }
      Pool[CurrentPageIndex] = v70 + 8 * CurrentPageIndex;
      result3 = SkmiLockImagePage(
                  *(_QWORD *)(pNarTreeEntry + 0x38),
                  HashStartVaAndNarBasePageDistance,
                  pCopiedHashMdl2->Pfns[CurrentPageIndex],
                  2);
      result4 = result3;
      if ( result3 < 0 )
        goto LABEL_57;
      v33 = SkmiIncrementImagePageReferenceCount(pCopiedHashMdl->Pfns[CurrentPageIndex], 1);
      CurrentPageIndex = 0;
      if ( !v33 )
        result4 = 0xC0000043;
      result3 = result4;
      v72 = (signed __int64 *)Pool[i];
      PteTrace = SkmiGetPteTrace(
                   0,
                   v72,
                   v34,
                   (const signed __int64 *)(*v72 & 0xFFFFFFFFFFFFFFFDuLL),
                   (const signed __int64 *)*v72);
      v71 = PteTrace;
      if ( PteTrace )
      {
        BackTraceHash = 0;
        v36 = (PVOID *)(PteTrace + 4);
        memset_0(PteTrace + 4, 0, 0x40u);
        if ( (SkmiFlags & 0x400000) != 0
          && KeGetPcr()->NtTib.StackBase
          && !RtlCaptureStackBackTrace(v37, v26, v36, &BackTraceHash) )
        {
          v71[5] = retaddr;
          *v36 = SkmiGetInstructionPointer();
        }
        CurrentPageIndex = 0;
      }
      _InterlockedAnd64(v72, 0xFFFFFFFFFFFFFFFDuLL);
      if ( result4 < 0 )
        goto LABEL_57;
      goto LABEL_49;
    }
    pCopiedHashMdl2 = pCopiedHashMdl;
    if ( ((CurrentPteOfHashData >> 0xC) & 0xFFFFFFFFFFLL) != pCopiedHashMdl->Pfns[CurrentPageIndex] )// 
                                                // This checks the PFN from the original hash MDL with the copied VTL1 hash MDL.
      goto LABEL_38;
    Pool[CurrentPageIndex] = (__int64)pCurrentPteOfHashData;
    result3 = SkmiIncrementNtPageReferenceCount(HashMdlStartVa2, &v69, 0);
    result4 = result3;
    if ( result3 < 0 )
      goto LABEL_51;
    if ( v69 != pCopiedHashMdl->Pfns[CurrentPageIndex] )
    {
      result4 = 0xC0000018;
      result3 = 0xC0000018;
LABEL_51:
      v38 = 0x16;
LABEL_52:
      SKMI_SECURITY(v38);
LABEL_57:
      LODWORD(HashPageCount) = i;
      LOBYTE(v26) = (_BYTE)v78;
      if ( (_BYTE)v78 != 0xFF )
        RtlpReleasePropStoreLockShared(&SkmiNteLock, (unsigned __int8)v78);
      goto LABEL_71;
    }
    CurrentPageIndex = 0;
LABEL_49:
    HashMdlStartVa2 += 0x1000LL;
  }
  RtlpReleasePropStoreLockShared(&SkmiNteLock, (unsigned __int8)v78);
  result3 = SkciValidateDynamicCodePages(
              pCopiedTargetMdl->MappedSystemVa,
              pCopiedTargetMdl->ByteCount,
              pParams->pCopiedHashMdl->MappedSystemVa,
              pParams->pCopiedHashMdl->ByteCount);
  result4 = result3;
  if ( result3 >= 0 )
  {
    if ( TargetMdlPageCount )
    {
      v40 = (char *)((char *)pCopiedTargetMdlPfnArray - (char *)pPteOfTargetCode);
      v41 = TargetMdlPageCount;
      do
      {
        SkmiProtectSinglePage(*(signed __int64 *)((char *)pPteOfTargetCode + (_QWORD)v40), 2u);// The first parameter is the dereference of the pCopiedTargetMdlPfnArray
        v42 = (const signed __int64 *)(((*(signed __int64 *)((_BYTE *)pPteOfTargetCode + (_QWORD)v40) & 0xFFFFFFFFFFLL) << 0xC)
                                     | 0x200000000000221LL);
        v44 = SkmiGetPteTrace(0, pPteOfTargetCode, v43, v42, (const signed __int64 *)*pPteOfTargetCode);
        v78 = v44;
        if ( v44 )
        {
          LODWORD(pNarTreeEntry) = 0;
          v45 = (PVOID *)(v44 + 4);
          memset_0(v44 + 4, 0, 0x40u);
          if ( (SkmiFlags & 0x400000) != 0
            && KeGetPcr()->NtTib.StackBase
            && !RtlCaptureStackBackTrace(v46, v26, v45, (PULONG)&pNarTreeEntry) )
          {
            v78[5] = retaddr;
            *v45 = SkmiGetInstructionPointer();
          }
        }
        *pPteOfTargetCode++ = (signed __int64)v42;
        --v41;
      }
      while ( v41 );
      result4 = result3;
      LODWORD(HashPageCount) = HashPageCount2;
    }
    pPteOfTargetCode = 0;
  }
LABEL_71:
  v47 = Pool;
  if ( Pool )
  {
    if ( (_DWORD)HashPageCount )
    {
      v48 = Pool;
      HashPageCount = (unsigned int)HashPageCount;
      do
      {
        SkmiDecrementPageReferenceCount((*(_QWORD *)*v48++ >> 0xC) & 0xFFFFFFFFFFLL);
        --HashPageCount;
      }
      while ( HashPageCount );
      result4 = result3;
      v47 = Pool;
    }
    if ( v60 )
      SkFreePool(0x200, (ULONG_PTR)v47);
  }
LABEL_78:
  if ( pPteOfTargetCode )
  {
    if ( TargetMdlPageCount )
    {
      v49 = (char *)((char *)pCopiedTargetMdlPfnArray - (char *)pPteOfTargetCode);
      v50 = TargetMdlPageCount;
      do
      {
        SkmiReleasePhysicalPage(*(_QWORD *)&v49[(_QWORD)pPteOfTargetCode], v26);
        v51 = (const signed __int64 *)(*pPteOfTargetCode & 0xFFFFFFFFFFFFFBFFuLL);
        v53 = SkmiGetPteTrace(0, pPteOfTargetCode, v52, v51, (const signed __int64 *)*pPteOfTargetCode);
        v54 = v53;
        if ( v53 )
        {
          LODWORD(pParams) = 0;
          v55 = (PVOID *)(v53 + 4);
          memset_0(v53 + 4, 0, 0x40u);
          if ( (SkmiFlags & 0x400000) != 0
            && KeGetPcr()->NtTib.StackBase
            && !RtlCaptureStackBackTrace(v56, v26, v55, (PULONG)&pParams) )
          {
            v54[5] = retaddr;
            *v55 = SkmiGetInstructionPointer();
          }
        }
        *pPteOfTargetCode++ = (signed __int64)v51;
        --v50;
      }
      while ( v50 );
      result4 = result3;
    }
    LOBYTE(v57) = SkmiAcquireNteAssertionLock();
    SkmiReleaseNteAssertionLock(v57);
  }
LABEL_91:
  if ( pCopiedTargetMdl )
    SkmmUnmapDataTransfer((ULONG_PTR)pCopiedTargetMdl);
  return (unsigned int)result4;
}
```

## SkciValidateDynamicCodePages

```c
__int64 __fastcall SkciValidateDynamicCodePages(
        __int64 pTargetCode,
        __int64 TargetByteCount,
        __int64 pHash,
        unsigned __int64 HashByteCount)
{
  __int64 result; // rax

  result = CiValidateFullImagePages(pTargetCode, TargetByteCount, 0x800E, pHash, HashByteCount >> 5, 0x20, 0x20, 0x20);// Only outputs 0 or 0xC0000428
  if ( (int)result >= 0 )
    return 0x12C;
  return result;                                // Only outputs 0x12C or 0xC0000428
}
```

## CiValidateFullImagePages

```c
__int64 __fastcall CiValidateFullImagePages(
        __int64 pTargetCode,
        unsigned __int64 TargetByteCount,
        __int64 HashType,
        __int64 pHashData,
        unsigned __int64 HashCount,
        unsigned int CompareSize,
        unsigned int a7,
        unsigned int CompareOffset)
{
  __int64 pParallelHashingContext; // rbx
  unsigned __int64 TargetPageCount; // rdi
  __int64 result; // rax
  unsigned int v14; // r8d
  unsigned int CurrentComparisonPageCount; // esi
  __int64 v16; // rax
  __int64 v17; // rdx
  char *pGeneratedHashOutput; // r14
  unsigned int i; // ebp
  char GeneratedHashOutput; // [rsp+40h] [rbp-88h] BYREF

  pParallelHashingContext = 0;
  TargetPageCount = TargetByteCount >> 0xC;
  if ( TargetByteCount >> 0xC > HashCount )
    return 0xC0000428LL;
  if ( TargetPageCount > 1 && (_DWORD)HashType == 0x800C )
    pParallelHashingContext = CipAcquireParallelHashingContext();
LABEL_6:
  if ( TargetPageCount )
  {
    if ( pParallelHashingContext && TargetPageCount > 1 )// Only SHA256 can generate hash of maximum 8 pages each time, 
                                                // other hash will generate the hash and compare one by one
    {
      v14 = 0;
      if ( TargetPageCount >= 8 )
        CurrentComparisonPageCount = 8;
      else
        CurrentComparisonPageCount = TargetPageCount;
      do
      {
        v16 = 0xALL * v14;
        v17 = pTargetCode + (v14++ << 0xC);
        *(_QWORD *)(pParallelHashingContext + 8 * v16 + 0x510) = v17;
      }
      while ( v14 < CurrentComparisonPageCount );
      SymCryptParallelSha256Process(
        pParallelHashingContext + 0x100,
        CurrentComparisonPageCount,
        pParallelHashingContext + 0x500,
        2 * CurrentComparisonPageCount,
        pParallelHashingContext + 0x780,
        0xB6E);
      pGeneratedHashOutput = (char *)pParallelHashingContext;
    }
    else
    {
      CurrentComparisonPageCount = 1;
      HashKComputeMemoryHash(HashType, pTargetCode);
      pGeneratedHashOutput = &GeneratedHashOutput;
    }
    for ( i = 0; ; ++i )
    {
      if ( i >= CurrentComparisonPageCount )    // Loop ends, all equal
      {
        TargetPageCount -= CurrentComparisonPageCount;
        pTargetCode += CurrentComparisonPageCount << 0xC;
        goto LABEL_6;                           // Jump above, go to the next page of target memory if exist
      }
      if ( memcmp_0(&pGeneratedHashOutput[CompareOffset], (const void *)pHashData, CompareSize) )
        break;                                  // not equal, outputs 0xC0000428
      pGeneratedHashOutput += 0x20;
      pHashData += a7;
    }
    result = 0xC0000428LL;
  }
  else
  {
    result = 0;                                 // All pages validated
  }
  if ( pParallelHashingContext )
    _interlockedbittestandset(
      &g_CiParallelPageHashContextsAvailableMask,
      0xD410E5CF * ((pParallelHashingContext - g_CiParallelPageHashContexts) >> 4));
  return result;
}
```

## SkmiLockDriverNtAddresses

```c
__int64 __fastcall SkmiLockDriverNtAddresses(
        __int64 TargetMdlStartVaAndNarRangeBasePageDistance,
        unsigned __int64 TargetMdlStartVa,
        unsigned int TargetMdlPageCount)
{
  unsigned __int64 pPteOfTarget; // rsi
  signed __int64 *pPteOfTarget2; // rdi
  unsigned __int64 pPteOfTargetEnd; // r8
  signed __int64 PteOfTarget; // rax
  signed __int64 v7; // rdx
  __int64 v8; // r8
  const signed __int64 *v9; // rbx
  const signed __int64 **PteTrace; // rax
  const signed __int64 **v11; // rbp
  PVOID *v12; // r14
  ULONG v13; // edx
  ULONG v14; // ecx
  const signed __int64 *retaddr; // [rsp+48h] [rbp+0h]
  ULONG BackTraceHash; // [rsp+60h] [rbp+18h] BYREF

  pPteOfTarget = ((TargetMdlStartVa >> 9) & 0x7FFFFFFFF8LL) - 0xA0000000000LL;
  pPteOfTarget2 = (signed __int64 *)pPteOfTarget;
  pPteOfTargetEnd = pPteOfTarget + 8 * (TargetMdlPageCount - 1LL);
LABEL_2:
  if ( (unsigned __int64)pPteOfTarget2 > pPteOfTargetEnd )
    return 0;
  _m_prefetchw(pPteOfTarget2);
  PteOfTarget = *pPteOfTarget2;
  while ( (PteOfTarget & 0x200) != 0 && (PteOfTarget & 0x801) != 1 && (PteOfTarget & 0x500) == 0 )// From ChatGPT:
                                                // As long as the PTE is accessible or transitional, not a standard valid PTE, not global, 
                                                // and not already locked, set its lock bit atomically
  {
    v7 = PteOfTarget;
    PteOfTarget = _InterlockedCompareExchange64(pPteOfTarget2, PteOfTarget | 0x400, PteOfTarget);// in _MMPTE_HARDWARE, bit 10 is Unused
    if ( PteOfTarget == v7 )
    {
      ++pPteOfTarget2;
      goto LABEL_2;
    }
  }
  SKMI_SECURITY(0x135);
  for ( ; (unsigned __int64)pPteOfTarget2 > pPteOfTarget; *pPteOfTarget2 = (signed __int64)v9 )
  {
    pPteOfTarget2 += 0xFFFFFFFF;
    v9 = (const signed __int64 *)(*pPteOfTarget2 & 0xFFFFFFFFFFFFFBFFuLL);
    PteTrace = SkmiGetPteTrace(0, pPteOfTarget2, v8, v9, (const signed __int64 *)*pPteOfTarget2);
    v11 = PteTrace;
    if ( PteTrace )
    {
      BackTraceHash = 0;
      v12 = (PVOID *)(PteTrace + 4);
      memset_0(PteTrace + 4, 0, 0x40u);
      if ( (SkmiFlags & 0x400000) != 0 )
      {
        if ( KeGetPcr()->NtTib.StackBase )
        {
          if ( !RtlCaptureStackBackTrace(v14, v13, v12, &BackTraceHash) )
          {
            v11[5] = retaddr;
            *v12 = SkmiGetInstructionPointer();
          }
        }
      }
    }
  }
  return 0xC0000005LL;
}
```
