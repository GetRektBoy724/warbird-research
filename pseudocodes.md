# Pseudocodes

You can check the pseudocodes that generated by IDA and cleaned up as good as Im able to.

## _PAGEWX_PREPARATION_INFO

```c
struct _PAGEWX_PREPARATION_INFO
{
  DWORD64 NewMdlVa;
  DWORD64 NewMdlLength;
  DWORD64 MdlVaToMappingOffset;
  DWORD IsEncrypt;
  DWORD Unknown5;
  DWORD64 PAGEwxN;
  DWORD64 NewMdl;
  DWORD64 Mdl;
  DWORD IsNewMdlLocked;
  DWORD Unknown9;
  DWORD64 MdlVaOrSectionVa;
  DWORD64 LockedMappedMdlVa;
  DWORD64 MdlLength;
  DWORD64 PAGEwxIndex;
};
```

## WarbirdDecryptSection

```c
__int64 __fastcall WarbirdDecryptSection(unsigned int *DecryptionData1, int *DecryptionData2)
{
  int result; // edi
  int decryptionCount; // eax

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 )
  {
    if ( decryptionCount != -1 )
      *DecryptionData2 = decryptionCount + 1;
  }
  else
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 0);
    if ( result >= 0 )
      *DecryptionData2 = 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return (unsigned int)result;
}
```

## WarbirdReencryptSection

```c
__int64 __fastcall WarbirdReencryptSection(_DWORD *DecryptionData1, int *DecryptionData2)
{
  int decryptionCount; // ecx
  unsigned int result; // eax MAPDST

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 == 1 )
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 1u);
    *DecryptionData2 = 0;
  }
  else if ( (unsigned int)(decryptionCount - 1) <= 0xFFFFFFFD )
  {
    *DecryptionData2 = decryptionCount - 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return result;
}
```

## WarbirdEncryptDecryptSection

```c
__int64 __fastcall WarbirdEncryptDecryptSection(__int64 DecryptionData1, __int64 DecryptionData2, DWORD IsEncrypt)
{
  int result; // esi
  unsigned int i; // r14d
  unsigned __int64 NewMdlVaLength2; // r8
  DWORD64 NewMdlVa; // rbx
  DWORD64 NewMdlVaEnd; // r13
  unsigned __int64 v10; // r9
  unsigned int v11; // edx
  _PAGEWX_PREPARATION_INFO SectionInfo; // [rsp+40h] [rbp-39h] BYREF
  unsigned int NewMdlVaLength; // [rsp+E0h] [rbp+67h] BYREF

  SectionInfo.PAGEwxN = (unsigned __int8)((unsigned __int64)*(unsigned int *)DecryptionData1 >> 1);
  memset(&SectionInfo, 0, 24);
  result = 0;
  SectionInfo.IsEncrypt = IsEncrypt;
  memset(&SectionInfo.NewMdl, 0, 20);
  memset(&SectionInfo.MdlVaOrSectionVa, 0, 32);
  if ( !(unsigned int)WarbirdPrepareSectionForModification(&SectionInfo) )
    return 0x80070005LL;
  i = 0;
  if ( *(_WORD *)(DecryptionData1 + 80) )
  {
    do
    {
      if ( result < 0 )
        break;
      NewMdlVa = 0x180000000LL + ((*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF);
      NewMdlVaLength = *(_DWORD *)(DecryptionData1 + 8LL * i + 88) & 0xFFFFFFF;
      NewMdlVaLength2 = NewMdlVaLength;
      NewMdlVaEnd = NewMdlVa + NewMdlVaLength;
      if ( NewMdlVa < SectionInfo.NewMdlVa || NewMdlVaEnd >= SectionInfo.NewMdlLength + SectionInfo.NewMdlVa )
      {
        WarbirdCleanUpMdl(&SectionInfo);
        SectionInfo.NewMdlVa = NewMdlVa & 0xFFFFFFFFFFFFF000uLL;
        SectionInfo.NewMdlLength = ((NewMdlVaEnd + 4095) & 0xFFFFFFFFFFFFF000uLL) - (NewMdlVa & 0xFFFFFFFFFFFFF000uLL);
        if ( !(unsigned int)WarbirdSetupNewMdl(&SectionInfo) )
          goto LABEL_19;
        NewMdlVaLength2 = NewMdlVaLength;
      }
      if ( NewMdlVa + SectionInfo.MdlVaToMappingOffset )
      {
        v10 = *(_QWORD *)(DecryptionData1 + 8);
        v11 = *(unsigned __int16 *)(DecryptionData2 + 2LL * i + 4);
        if ( IsEncrypt )
        {
          if ( (v11 & 0x8000u) == 0 )
          {
            LOBYTE(NewMdlVaLength) = 0;
            WarbirdFeistelEncrypt(
              (char *)NewMdlVa,
              (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
              NewMdlVaLength2,
              v10,
              (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
              &NewMdlVaLength);
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4) = NewMdlVaLength;
            *(_WORD *)(DecryptionData2 + 2LL * i + 4) |= 0x8000u;
          }
        }
        else if ( (v11 & 0x8000) != 0 )
        {
          LOWORD(v11) = ~(_WORD)v11;
          WarbirdFeistelDecrypt(
            (_BYTE *)NewMdlVa,
            (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
            NewMdlVaLength2,
            v10,
            (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4),
            (v11 >> 8) & 1);
          *(_WORD *)(DecryptionData2 + 2LL * i + 4) = *(_WORD *)(DecryptionData2 + 2LL * i + 4) & 0x7EFF | 0x100;
        }
        goto LABEL_10;
      }
LABEL_19:
      result = 0x8007000E;
LABEL_10:
      ++i;
    }
    while ( i < (unsigned __int16)*(_DWORD *)(DecryptionData1 + 80) );
  }
  WarbirdCleanUpMdl(&SectionInfo);
  if ( !WarbirdFinishSectionModification(&SectionInfo) )
    return 0x8007000E;
  return (unsigned int)result;
}
```

## WarbirdPrepareSectionForModification

```c
__int64 __fastcall WarbirdPrepareSectionForModification(_PAGEWX_PREPARATION_INFO *pSectionInfo)
{
  __int64 PAGEwxIndex; // r8
  unsigned int *PAGEwxN; // r9
  void *pTargetRVA; // rcx
  DWORD64 TargetLength; // rax
  struct _MDL *pTargetMdl; // rax
  PMDL *ppSectionMdl; // rsi
  PVOID LockedDataSectionHandle; // r14
  PMDL pMdl; // r10
  PVOID MappedSystemVa; // rax
  DWORD64 *p_Mdl; // rdi
  unsigned int IsSucceed; // [rsp+30h] [rbp-28h]

  IsSucceed = 1;
  PAGEwxIndex = 0;
  PAGEwxN = &StoredPAGEwxData[0].PAGEwxN;
  do
  {
    if ( *PAGEwxN == pSectionInfo->PAGEwxN )
      break;
    PAGEwxIndex = (unsigned int)(PAGEwxIndex + 1);
    PAGEwxN += 5;
  }
  while ( (unsigned int)PAGEwxIndex < 6 );
  if ( (_DWORD)PAGEwxIndex != 6 )
  {
    pSectionInfo->PAGEwxIndex = (unsigned int)PAGEwxIndex;
    pTargetRVA = (void *)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA);
    pSectionInfo->MdlVaOrSectionVa = (DWORD64)pTargetRVA;
    TargetLength = StoredPAGEwxData[PAGEwxIndex].PageCount << 12;
    pSectionInfo->MdlLength = TargetLength;
    pTargetMdl = IoAllocateMdl(pTargetRVA, TargetLength, 0, 0, 0);
    ppSectionMdl = (PMDL *)&pSectionInfo->Mdl;
    pSectionInfo->Mdl = (DWORD64)pTargetMdl;
    if ( pTargetMdl )
    {
      MmProbeAndLockPages(pTargetMdl, 0, IoModifyAccess);
      if ( (int)MmChangeImageProtection(
                  *ppSectionMdl,
                  (unsigned int)PAGEwxHashRVA
                + 32LL * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].HashIndex
                + 0x180000020LL,
                  32 * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].PageCount,
                  2) < 0 )
      {
        MmUnlockPages(*ppSectionMdl);
        IsSucceed = 0;
      }
      else
      {
        LockedDataSectionHandle = 0;
        if ( !pSectionInfo->IsEncrypt )
        {
          LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL
                                                                   + StoredPAGEwxData[pSectionInfo->PAGEwxIndex].RVA));
          ++LockedPagableDataSectionCount;
        }
        pMdl = *ppSectionMdl;
        if ( ((*ppSectionMdl)->MdlFlags & 5) != 0 )
          MappedSystemVa = pMdl->MappedSystemVa;
        else
          MappedSystemVa = MmMapLockedPagesSpecifyCache(pMdl, 0, MmCached, 0, 0, 0x40000020u);
        pSectionInfo->LockedMappedMdlVa = (DWORD64)MappedSystemVa;
        if ( !MappedSystemVa )                  // If failed
        {
          if ( !pSectionInfo->IsEncrypt && LockedDataSectionHandle )
          {
            MmUnlockPagableImageSection(LockedDataSectionHandle);
            ++UnlockedPagableImageSectionCount;
          }
          WarbirdChangeImageProtection(pSectionInfo, 0);
          MmUnlockPages(*ppSectionMdl);
          IsSucceed = 0;
          ++qword_1800DAEB8;
        }
      }
      if ( IsSucceed )
        return IsSucceed;
      p_Mdl = &pSectionInfo->Mdl;
    }
    else
    {
      IsSucceed = 0;
      p_Mdl = &pSectionInfo->Mdl;
    }
    if ( *ppSectionMdl )
    {
      IoFreeMdl(*ppSectionMdl);
      *p_Mdl = 0;
    }
    return IsSucceed;
  }
  return 1;
}
```

## WarbirdFinishSectionModification

```c
_BOOL8 __fastcall WarbirdFinishSectionModification(_PAGEWX_PREPARATION_INFO *pPagesInfo)
{
  struct _MDL *pSectionMdl; // rdx
  BOOL IsSucceed; // ebp
  DWORD64 PAGEwxIndex; // rax
  PVOID LockedDataSectionHandle; // rax MAPDST
  _BOOL8 result; // rax
  __int64 HashRVA; // r14
  unsigned int PageCount; // ebx
  __int64 HashIndex; // r15
  void *LockedMappedMdlVa; // rcx

  pSectionMdl = (struct _MDL *)pPagesInfo->Mdl;
  IsSucceed = 1;
  if ( pSectionMdl )
  {
    PAGEwxIndex = pPagesInfo->PAGEwxIndex;
    if ( pPagesInfo->IsEncrypt )
    {
      LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA));
      ++LockedPagableDataSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
    }
    else
    {
      HashRVA = (unsigned int)PAGEwxHashRVA;
      PageCount = StoredPAGEwxData[PAGEwxIndex].PageCount;
      HashIndex = StoredPAGEwxData[PAGEwxIndex].HashIndex;
      LockedMappedMdlVa = (void *)pPagesInfo->LockedMappedMdlVa;
      if ( LockedMappedMdlVa )
      {
        MmUnmapLockedPages(LockedMappedMdlVa, pSectionMdl);
        pPagesInfo->LockedMappedMdlVa = 0;
      }
      IsSucceed = (int)MmChangeImageProtection(
                         pPagesInfo->Mdl,
                         HashRVA + 32 * HashIndex + 0x180000020LL,
                         32 * PageCount,
                         1) >= 0;
    }
    MmUnlockPages((PMDL)pPagesInfo->Mdl);
    IoFreeMdl((PMDL)pPagesInfo->Mdl);
    pPagesInfo->Mdl = 0;
  }
  pPagesInfo->MdlVaOrSectionVa = 0;
  result = IsSucceed;
  pPagesInfo->LockedMappedMdlVa = 0;
  pPagesInfo->MdlLength = 0;
  pPagesInfo->PAGEwxIndex = 0;
  pPagesInfo->MdlVaToMappingOffset = 0;
  return result;
}
```

## MmChangeImageProtection

```c
__int64 __fastcall MmChangeImageProtection(
        _MDL *pTargetMdl,
        unsigned __int64 pHash,
        __int64 HashSize,
        int ProtectionFlags)
{
  int HashSize2; // r13d
  ULONG TargetMdlByteCount; // ebp
  unsigned int TargetMdlPageCount; // ebp
  _KLDR_DATA_TABLE_ENTRY *pModuleTableEntry; // rax MAPDST
  int output; // ebx
  char *TargetModuleBase; // r8
  unsigned __int64 pHashEnd; // rdx
  char *TargetModuleEnd; // rax
  unsigned int Flags; // eax
  unsigned __int64 *pTargetMdlPfnArray; // r15
  __int64 i; // r14
  _MMPFN *pCurrentPfnDatabaseEntry; // rcx
  unsigned int v21; // r9d
  __int64 v22; // rdi
  _DWORD IsLdrTableLocked[14]; // [rsp+20h] [rbp-38h] BYREF

  IsLdrTableLocked[0] = 0;
  if ( (unsigned int)(ProtectionFlags - 1) > 1 )// Only accepts ProtectionFlag either 1 or 2
    return 0xC000000DLL;
  HashSize2 = HashSize;
  if ( HashSize != (unsigned int)HashSize )
    return 0xC000000DLL;
  if ( (pTargetMdl->MdlFlags & 7) != 2 )
    return 0xC000000DLL;
  if ( pTargetMdl->ByteOffset )
    return 0xC000000DLL;
  TargetMdlByteCount = pTargetMdl->ByteCount;
  if ( (TargetMdlByteCount & 0xFFF) != 0 )
    return 0xC000000DLL;
  TargetMdlPageCount = TargetMdlByteCount >> 0xC;
  pModuleTableEntry = (_KLDR_DATA_TABLE_ENTRY *)MiLockLoadedDataTableEntryIfNecessary(
                                                  (__int64)pTargetMdl->StartVa,
                                                  IsLdrTableLocked);
  if ( pModuleTableEntry )
  {
    TargetModuleBase = (char *)pModuleTableEntry->DllBase;
    pHashEnd = pHash + HashSize;
    TargetModuleEnd = &TargetModuleBase[pModuleTableEntry->SizeOfImage];
    if ( (char *)pTargetMdl->StartVa + pTargetMdl->ByteCount > TargetModuleEnd
      || pHash < (unsigned __int64)TargetModuleBase
      || pHashEnd > (unsigned __int64)TargetModuleEnd
      || pHashEnd - 1 < pHash )
    {
      output = 0xC0000018;
    }
    else
    {
      Flags = pModuleTableEntry->Flags;
      if ( (Flags & 0x80000) != 0 )
      {
        output = 0xC0000043;
      }
      else
      {
        output = 0;
        pModuleTableEntry->Flags = Flags | 0x80000;
        if ( (unsigned int)MI_IS_PHYSICAL_ADDRESS((unsigned __int64)TargetModuleBase) )
        {
LABEL_34:
          output = 0xC0000018;
        }
        else
        {
          pTargetMdlPfnArray = (unsigned __int64 *)&pTargetMdl[1];
          for ( i = 0; (unsigned int)i < TargetMdlPageCount; i = (unsigned int)(i + 1) )
          {
            pCurrentPfnDatabaseEntry = (_MMPFN *)(0x30 * pTargetMdlPfnArray[i] - 0x220000000000LL);// Get PFN database (MMPFN)
            if ( (pCurrentPfnDatabaseEntry->u4.EntireField & 0x8000000000000000uLL) != 0LL )// Checks if PrototypePte flag is set.
              goto LABEL_34;
            if ( (MiGetPagePrivilege((ULONG_PTR)pCurrentPfnDatabaseEntry) & 0x40) != 0 )
            {
              output = 0xC0000045;
              goto LABEL_24;
            }
          }
          MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, 1u);// Protection set to writable
          if ( ProtectionFlags == 1 )
          {
            if ( (MiFlags & 0x4000) == 0
              || (output = VslValidateDynamicCodePages((__int64)pTargetMdl, pHash, HashSize2), output >= 0) )
            {
              v21 = 3;
              if ( (MiFlags & 0x8000) != 0 && output == 0x12C )
                v21 = 0x13;
              MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, v21);// Protection set to executable
              output = 0;
            }
          }
          else if ( (MiFlags & 0x8000) != 0 && TargetMdlPageCount )
          {
            v22 = TargetMdlPageCount;
            do
            {
              MiClearPfnImageVerified(0x30 * *pTargetMdlPfnArray++ - 0x220000000000LL, 9);
              --v22;
            }
            while ( v22 );
          }
        }
LABEL_24:
        pModuleTableEntry->Flags &= ~0x80000u;
      }
    }
    if ( IsLdrTableLocked[0] )
      MmUnlockLoadedDataTableEntry(pModuleTableEntry);
  }
  else
  {
    return 0xC0000225;
  }
  return (unsigned int)output;
}
```

## VslValidatesDynamicCodePages

```c
__int64 __fastcall VslValidateDynamicCodePages(_MDL *pTargetMdl, unsigned __int64 pHash, unsigned int HashSize)
{
  SIZE_T SizeOfTargetMdl; // rax
  unsigned __int64 TargetMdlPageCount; // rdx
  int result; // ebx
  _VSLP_TRANSFER_STRUCTURE HashTransferData; // [rsp+30h] [rbp-118h] BYREF
  _SSCN_20H_SKCALL SKCALLPacket; // [rsp+80h] [rbp-C8h] BYREF
  struct _MDL TargetMdlLvl2; // [rsp+F0h] [rbp-58h] BYREF
  unsigned __int64 TargetMdlLvl2Pfn; // [rsp+120h] [rbp-28h]

  memset_0(&SKCALLPacket, 0, sizeof(SKCALLPacket));
  memset(&TargetMdlLvl2.MdlFlags + 1, 0, 0x14);
  TargetMdlLvl2Pfn = 0;
  memset_0(&HashTransferData, 0, sizeof(HashTransferData));
  SizeOfTargetMdl = MmSizeOfMdl(pTargetMdl->StartVa, pTargetMdl->ByteCount + pTargetMdl->ByteOffset);
  TargetMdlPageCount = (SizeOfTargetMdl + ((unsigned __int16)pTargetMdl & 0xFFF) + 0xFFFLL) >> 0xC;
  if ( TargetMdlPageCount > 1 )
    return 0xC000000DLL;
  TargetMdlLvl2.Next = 0;
  TargetMdlLvl2.Size = 8 * (TargetMdlPageCount + 6);
  TargetMdlLvl2.MdlFlags = 0;
  TargetMdlLvl2.StartVa = (PVOID)((unsigned __int64)pTargetMdl & 0xFFFFFFFFFFFFF000uLL);
  TargetMdlLvl2.ByteOffset = (unsigned __int16)pTargetMdl & 0xFFF;
  TargetMdlLvl2.ByteCount = SizeOfTargetMdl;
  MmProbeAndLockPages(&TargetMdlLvl2, 0, IoReadAccess);
  result = VslpLockPagesForTransfer(&HashTransferData, pHash, HashSize, IoReadAccess, 0);
  if ( result >= 0 )
  {
    SKCALLPacket.pTargetMdl = pTargetMdl;
    SKCALLPacket.TargetMdlLvl2Pfn = TargetMdlLvl2Pfn;
    SKCALLPacket.pHashMdlLvl1 = HashTransferData.pFirstLevelMdl;
    SKCALLPacket.HashMdlLvl2Pfn = HashTransferData.SecondLevelMdlPfn;
    result = VslpEnterIumSecureMode(2u, 0x20u, 0, (__int64)&SKCALLPacket);// 2 = Invoke Secure Service
                                                // 0x20 = SSCN
    VslpUnlockPagesForTransfer(&HashTransferData);
  }
  MmUnlockPages(&TargetMdlLvl2);
  return (unsigned int)result;
}
```

## _VSLP_TRANSFER_STRUCTURE

```c
struct _VSLP_TRANSFER_STRUCTURE
{
  _MDL *pFirstLevelMdl;
  _MDL SecondLevelMdl;
  unsigned __int64 SecondLevelMdlPfn;
  unsigned int Flags;
};
```

## _SSCN_20H_PACKET

```c
struct _SSCN_20H_SKCALL
{
  BYTE Unknown1;
  BYTE Unknown2;
  WORD SSCN;
  DWORD Unknown3;
  _MDL *pTargetMdl;
  unsigned __int64 TargetMdlLvl2Pfn;
  _MDL *pHashMdlLvl1;
  unsigned __int64 HashMdlLvl2Pfn;
  BYTE UnknownData[64];
};
```

## IumInvokeSecureService case 0x20

```c
      case 0x20:
          HashMdlLvl2Pfn = *((_QWORD *)SKCALLPacket + 4);
          pHashMdl = (_MDL *)*((_QWORD *)SKCALLPacket + 3);
          TargetMdlLvl2Pfn = *((_QWORD *)SKCALLPacket + 2);
          pTargetMdl = (_MDL *)*((_QWORD *)SKCALLPacket + 1);
          memset(&SSCN_20H_Params, 0, sizeof(SSCN_20H_Params));
          if ( (SkmiFlags & 0x10) == 0 )
            goto LABEL_377;
          result = SkmmMapDataTransfer(
                     pHashMdl,
                     HashMdlLvl2Pfn,
                     0x80000001,
                     &SSCN_20H_Params.pCopiedHashMdl,
                     &SSCN_20H_Params.HashMdlStartVa);// Maps the hash to VTL1
          if ( result < 0 )
            goto LABEL_377;
          if ( SSCN_20H_Params.pCopiedHashMdl->ByteCount )
          {
            SSCN_20H_Params.pTargetMdl = pTargetMdl;
            SSCN_20H_Params.TargetMdlLvl2Pfn = TargetMdlLvl2Pfn;
            result = SkmiOperateOnLockedNar(
                       SSCN_20H_Params.HashMdlStartVa,
                       (__int64 (__fastcall *)(_QWORD *, __int64))SkmiValidateDynamicCodePages,
                       (__int64)&SSCN_20H_Params);
          }
          else
          {
            result = 0xC000000D;
          }
          SkmmUnmapDataTransfer(SSCN_20H_Params.pCopiedHashMdl);
          goto LABEL_1227;
```

## SkmiValidateDynamicCodePages

```c
__int64 __fastcall SkmiValidateDynamicCodePages(__int64 pNarTreeEntry, _SkmiValidateDynamicCodePages_Params *pParams)
{
  __int16 v2; // r8
  int HashMdlStartVa; // ecx
  unsigned int v6; // r12d
  __int64 HashByteCount; // r8
  ULONG_PTR TargetMdlLvl2Pfn; // rdx
  __int64 HashMdlRounding; // r14
  _MDL *pTargetMdl; // rcx
  unsigned __int64 HashPageCount; // r14
  __int64 result; // rax
  ULONG TargetMdlByteCount; // r13d
  unsigned __int64 v15; // rdx
  unsigned int TargetMdlPageCount; // r13d
  unsigned __int64 v17; // rcx
  int result2; // eax
  int result4; // esi
  __int64 *pPteOfTargetCode; // rdi
  unsigned __int64 *pCurrentCopiedTargetMdlPfnArray; // rbx
  __int64 TargetMdlPageCount2; // r15
  __int64 v23; // rax
  __int64 v24; // r15
  unsigned int v25; // r12d
  __int64 v26; // rdx
  unsigned int i; // ebx
  __int64 pCurrentPdeOfHashData; // rdx
  unsigned __int64 *pCurrentPteOfHashData; // rdx
  unsigned __int64 CurrentPteOfHashData; // rax
  _MDL *pCopiedHashMdl2; // r8
  __int64 v33; // r8
  int v34; // eax
  int v35; // r8d
  __int64 PteTrace; // rax
  PVOID *v37; // r15
  ULONG v38; // ecx
  __int64 v39; // rcx
  __int64 v40; // rcx
  __int64 v41; // rcx
  char *v42; // r15
  __int64 v43; // r14
  __int64 v44; // rbx
  int v45; // r8d
  __int64 v46; // rax
  PVOID *v47; // r12
  ULONG v48; // edx
  ULONG v49; // ecx
  __int64 v50; // rdx
  __int64 v51; // r8
  __int64 v52; // rcx
  __int64 *v53; // rax
  __int64 *v54; // rbx
  char *v55; // rsi
  __int64 v56; // r12
  unsigned __int64 v57; // rbx
  int v58; // r8d
  __int64 v59; // rax
  __int64 v60; // r15
  PVOID *v61; // r14
  ULONG v62; // edx
  ULONG v63; // ecx
  __int64 v64; // rdx
  __int64 v65; // rcx
  __int64 v66; // r8
  __int64 v67; // rcx
  __int64 v68; // rcx
  __int64 *Pool; // [rsp+30h] [rbp-69h]
  int v70; // [rsp+38h] [rbp-61h]
  _MDL *pCopiedHashMdl; // [rsp+40h] [rbp-59h]
  _MDL *pCopiedTargetMdl; // [rsp+48h] [rbp-51h] BYREF
  ULONG BackTraceHash; // [rsp+50h] [rbp-49h] BYREF
  unsigned int v74; // [rsp+54h] [rbp-45h]
  unsigned __int64 HashMdlStartVa2; // [rsp+58h] [rbp-41h] MAPDST
  unsigned __int64 *pCopiedTargetMdlPfnArray; // [rsp+60h] [rbp-39h]
  unsigned __int64 TargetMdlStartVa; // [rsp+68h] [rbp-31h] MAPDST BYREF
  unsigned __int64 pPteOfHashData; // [rsp+70h] [rbp-29h]
  __int64 v79; // [rsp+78h] [rbp-21h] BYREF
  __int64 v80; // [rsp+80h] [rbp-19h]
  __int64 v81; // [rsp+88h] [rbp-11h]
  volatile signed __int64 *v82; // [rsp+90h] [rbp-9h]
  unsigned __int64 HashPageCount2; // [rsp+98h] [rbp-1h]
  unsigned __int64 v84[2]; // [rsp+A0h] [rbp+7h] BYREF
  _UNKNOWN *retaddr; // [rsp+F8h] [rbp+5Fh]
  __int64 v88; // [rsp+110h] [rbp+77h]
  int result3; // [rsp+118h] [rbp+7Fh]

  v2 = *(_WORD *)(pNarTreeEntry + 0x5E);
  v79 = 0;
  pCopiedTargetMdl = 0;
  TargetMdlStartVa = 0;
  v70 = 0;
  *(_OWORD *)v84 = 0;
  if ( (v2 & 6) != 2 || (v2 & 8) != 0 )
  {
    v68 = 0x39;
    goto LABEL_96;
  }
  HashMdlStartVa = pParams->HashMdlStartVa;
  v6 = HashMdlStartVa - *(_DWORD *)(pNarTreeEntry + 0x18);
  pCopiedHashMdl = pParams->pCopiedHashMdl;
  HashByteCount = pParams->pCopiedHashMdl->ByteCount;
  if ( (unsigned int)HashByteCount + v6 <= v6
    || (unsigned int)HashByteCount + v6 > *(_DWORD *)(pNarTreeEntry + 0x58) << 0xC )
  {
    v68 = 0x1D;
LABEL_96:
    SKMI_SECURITY(v68);
    return 0xC0000018LL;
  }
  TargetMdlLvl2Pfn = pParams->TargetMdlLvl2Pfn;
  HashMdlRounding = (HashMdlStartVa & 0xFFF) + 0xFFFLL;
  pTargetMdl = pParams->pTargetMdl;
  HashPageCount = (unsigned __int64)(HashByteCount + HashMdlRounding) >> 0xC;
  HashPageCount2 = HashPageCount;
  result = SkmmMapDataTransfer(pTargetMdl, TargetMdlLvl2Pfn, 0x80000001, &pCopiedTargetMdl, &TargetMdlStartVa);// Maps the target memory to VTL1
  if ( (int)result < 0 )
    return result;
  if ( (TargetMdlStartVa & 0xFFF) != 0
    || (TargetMdlByteCount = pCopiedTargetMdl->ByteCount, (TargetMdlByteCount & 0xFFF) != 0) )// Make sure the target VA and size is page aligned
  {
    result4 = 0xC000000D;
    goto LABEL_91;
  }
  v15 = *(_QWORD *)(pNarTreeEntry + 0x18);
  TargetMdlPageCount = TargetMdlByteCount >> 0xC;
  pCopiedTargetMdlPfnArray = (unsigned __int64 *)&pCopiedTargetMdl[1];
  v74 = TargetMdlPageCount;
  if ( TargetMdlStartVa < v15
    || (v17 = TargetMdlPageCount + ((TargetMdlStartVa - v15) >> 0xC), v17 > *(unsigned int *)(pNarTreeEntry + 0x58)) )
  {
    SKMI_SECURITY(0x3A);
    result4 = 0xC0000018;
    goto LABEL_91;
  }
  result2 = SkmiLockDriverNtAddresses(v17, TargetMdlStartVa, TargetMdlPageCount);
  result3 = result2;
  result4 = result2;
  if ( result2 < 0 )
  {
    if ( result2 == 0xC0000018 )
      SKMI_SECURITY(0x18);
    goto LABEL_91;
  }
  pPteOfTargetCode = (__int64 *)(((TargetMdlStartVa >> 9) & 0x7FFFFFFFF8LL) - 0xA0000000000LL);
  if ( TargetMdlPageCount )
  {
    pCurrentCopiedTargetMdlPfnArray = pCopiedTargetMdlPfnArray;
    TargetMdlPageCount2 = TargetMdlPageCount;
    do
    {
      SkmiClaimPhysicalPage(*pCurrentCopiedTargetMdlPfnArray++);
      --TargetMdlPageCount2;
    }
    while ( TargetMdlPageCount2 );
  }
  v23 = *(_QWORD *)(pNarTreeEntry + 0x38);
  v24 = 0;
  if ( v23 )
  {
    v25 = v6 >> 0xC;
    v80 = *(_QWORD *)(v23 + 8) + 8LL * v25;
  }
  else
  {
    v25 = 0;
    v80 = 0;
  }
  pPteOfHashData = ((pParams->HashMdlStartVa >> 9) & 0x7FFFFFFFF8LL) - 0xA0000000000LL;
  if ( (unsigned int)HashPageCount <= 2 )
  {
    Pool = (__int64 *)v84;
  }
  else
  {
    v70 = HashPageCount;
    Pool = (__int64 *)SkAllocatePool(0x200, 8LL * (unsigned int)HashPageCount, 0x70536D4D);
    if ( !Pool )
    {
      result4 = 0xC000009A;
      result3 = 0xC000009A;
      goto LABEL_78;
    }
    v24 = 0;
  }
  HashMdlStartVa2 = pParams->HashMdlStartVa;
  LOBYTE(v88) = SkAcquireSpinLockShared(&SkmiNteLock);
  for ( i = 0; i < (unsigned int)HashPageCount; ++i )
  {
    if ( !i || (v24 = i, (((_WORD)pPteOfHashData + 8 * (_WORD)i) & 0xFF8) == 0) )
    {
      pCurrentPdeOfHashData = *(_QWORD *)((((pPteOfHashData + 8 * v24) >> 9) & 0x7FFFFFFFF8LL) - 0x98000000000LL);
      if ( (pCurrentPdeOfHashData & 1) == 0 || (pCurrentPdeOfHashData & 0x80u) != 0LL )// Check if PDE is present and is not large page (2MB), make sures it have individual PTEs
      {
        v41 = 0x20;
        goto LABEL_56;
      }
    }
    pCurrentPteOfHashData = (unsigned __int64 *)(pPteOfHashData + 8 * v24);
    CurrentPteOfHashData = *pCurrentPteOfHashData;
    if ( (*pCurrentPteOfHashData & 0x200) == 0 )
    {
      v41 = 0x22;
LABEL_56:
      SKMI_SECURITY(v41);
      result4 = 0xC0000005;
      result3 = 0xC0000005;
      goto LABEL_57;
    }
    if ( (*pCurrentPteOfHashData & 0x801) != 1 && (CurrentPteOfHashData & 0x100) == 0 )
    {
      pCopiedHashMdl2 = pCopiedHashMdl;
LABEL_38:
      if ( !v80 )
      {
        v40 = 0x3B;
        goto LABEL_52;
      }
      Pool[v24] = v80 + 8 * v24;
      result3 = SkmiLockImagePage(
                  *(_QWORD *)(pNarTreeEntry + 0x38),
                  v25,
                  *((_QWORD *)&pCopiedHashMdl2[1].Next + v24),
                  2);
      result4 = result3;
      if ( result3 < 0 )
        goto LABEL_57;
      v34 = SkmiIncrementImagePageReferenceCount(*((_QWORD *)&pCopiedHashMdl[1].Next + v24));
      v24 = 0;
      if ( !v34 )
        result4 = 0xC0000043;
      result3 = result4;
      v82 = (volatile signed __int64 *)Pool[i];
      PteTrace = SkmiGetPteTrace(0, (_DWORD)v82, v35, (unsigned int)*v82 & 0xFFFFFFFD, *v82);
      v81 = PteTrace;
      if ( PteTrace )
      {
        BackTraceHash = 0;
        v37 = (PVOID *)(PteTrace + 0x20);
        memset_0((void *)(PteTrace + 0x20), 0, 0x40u);
        if ( (SkmiFlags & 0x400000) != 0
          && KeGetPcr()->NtTib.StackBase
          && !RtlCaptureStackBackTrace(v38, v26, v37, &BackTraceHash) )
        {
          v39 = v81;
          *(_QWORD *)(v81 + 0x28) = retaddr;
          *v37 = (PVOID)SkmiGetInstructionPointer(v39, v26, v33);
        }
        v24 = 0;
      }
      _InterlockedAnd64(v82, 0xFFFFFFFFFFFFFFFDuLL);
      if ( result4 < 0 )
        goto LABEL_57;
      goto LABEL_49;
    }
    pCopiedHashMdl2 = pCopiedHashMdl;
    if ( ((CurrentPteOfHashData >> 0xC) & 0xFFFFFFFFFFLL) != *((_QWORD *)&pCopiedHashMdl[1].Next + v24) )
      goto LABEL_38;
    Pool[v24] = (__int64)pCurrentPteOfHashData;
    result3 = SkmiIncrementNtPageReferenceCount(HashMdlStartVa2, &v79, 0);
    result4 = result3;
    if ( result3 < 0 )
      goto LABEL_51;
    if ( v79 != *((_QWORD *)&pCopiedHashMdl[1].Next + v24) )
    {
      result4 = 0xC0000018;
      result3 = 0xC0000018;
LABEL_51:
      v40 = 0x16;
LABEL_52:
      SKMI_SECURITY(v40);
LABEL_57:
      LODWORD(HashPageCount) = i;
      LOBYTE(v26) = v88;
      if ( (_BYTE)v88 != 0xFF )
        RtlpReleasePropStoreLockShared(&SkmiNteLock, v26, v33);
      goto LABEL_71;
    }
    v24 = 0;
LABEL_49:
    HashMdlStartVa2 += 0x1000LL;
  }
  LOBYTE(v26) = v88;
  RtlpReleasePropStoreLockShared(&SkmiNteLock, v26, 0xFFFFFFFFFFLL);
  result3 = SkciValidateDynamicCodePages(
              pCopiedTargetMdl->MappedSystemVa,
              pCopiedTargetMdl->ByteCount,
              pParams->pCopiedHashMdl->MappedSystemVa,
              pParams->pCopiedHashMdl->ByteCount);
  result4 = result3;
  if ( result3 >= 0 )
  {
    if ( TargetMdlPageCount )
    {
      v42 = (char *)((char *)pCopiedTargetMdlPfnArray - (char *)pPteOfTargetCode);
      v43 = TargetMdlPageCount;
      do
      {
        SkmiProtectSinglePage(*(__int64 *)((char *)pPteOfTargetCode + (_QWORD)v42), 2u);// The first parameter is the dereference of the pCopiedTargetMdlPfnArray
        v44 = ((*(__int64 *)((_BYTE *)pPteOfTargetCode + (_QWORD)v42) & 0xFFFFFFFFFFLL) << 0xC) | 0x200000000000221LL;
        v46 = SkmiGetPteTrace(
                0,
                (_DWORD)pPteOfTargetCode,
                v45,
                (*(_DWORD *)((char *)pPteOfTargetCode + (_QWORD)v42) << 0xC) | 0x221u,
                *pPteOfTargetCode);
        v88 = v46;
        if ( v46 )
        {
          LODWORD(pNarTreeEntry) = 0;
          v47 = (PVOID *)(v46 + 0x20);
          memset_0((void *)(v46 + 0x20), 0, 0x40u);
          if ( (SkmiFlags & 0x400000) != 0
            && KeGetPcr()->NtTib.StackBase
            && !RtlCaptureStackBackTrace(v49, v48, v47, (PULONG)&pNarTreeEntry) )
          {
            v52 = v88;
            *(_QWORD *)(v88 + 0x28) = retaddr;
            *v47 = (PVOID)SkmiGetInstructionPointer(v52, v50, v51);
          }
        }
        *pPteOfTargetCode++ = v44;
        --v43;
      }
      while ( v43 );
      result4 = result3;
      LODWORD(HashPageCount) = HashPageCount2;
      TargetMdlPageCount = v74;
    }
    pPteOfTargetCode = 0;
  }
LABEL_71:
  v53 = Pool;
  if ( Pool )
  {
    if ( (_DWORD)HashPageCount )
    {
      v54 = Pool;
      HashPageCount = (unsigned int)HashPageCount;
      do
      {
        SkmiDecrementPageReferenceCount((*(_QWORD *)*v54++ >> 0xC) & 0xFFFFFFFFFFLL);
        --HashPageCount;
      }
      while ( HashPageCount );
      result4 = result3;
      v53 = Pool;
    }
    if ( v70 )
      SkFreePool(0x200, v53);
  }
LABEL_78:
  if ( pPteOfTargetCode )
  {
    if ( TargetMdlPageCount )
    {
      v55 = (char *)((char *)pCopiedTargetMdlPfnArray - (char *)pPteOfTargetCode);
      v56 = TargetMdlPageCount;
      do
      {
        SkmiReleasePhysicalPage(*(_QWORD *)&v55[(_QWORD)pPteOfTargetCode]);
        v57 = *pPteOfTargetCode & 0xFFFFFFFFFFFFFBFFuLL;
        v59 = SkmiGetPteTrace(
                0,
                (_DWORD)pPteOfTargetCode,
                v58,
                *(_DWORD *)pPteOfTargetCode & 0xFFFFFBFF,
                *pPteOfTargetCode);
        v60 = v59;
        if ( v59 )
        {
          LODWORD(pParams) = 0;
          v61 = (PVOID *)(v59 + 0x20);
          memset_0((void *)(v59 + 0x20), 0, 0x40u);
          if ( (SkmiFlags & 0x400000) != 0
            && KeGetPcr()->NtTib.StackBase
            && !RtlCaptureStackBackTrace(v63, v62, v61, (PULONG)&pParams) )
          {
            *(_QWORD *)(v60 + 0x28) = retaddr;
            *v61 = (PVOID)SkmiGetInstructionPointer(v65, v64, v66);
          }
        }
        *pPteOfTargetCode++ = v57;
        --v56;
      }
      while ( v56 );
      result4 = result3;
    }
    LOBYTE(v67) = SkmiAcquireNteAssertionLock();
    SkmiReleaseNteAssertionLock(v67);
  }
LABEL_91:
  if ( pCopiedTargetMdl )
    SkmmUnmapDataTransfer(pCopiedTargetMdl);
  return (unsigned int)result4;
}
```

## SkciValidateDynamicCodePages

```c
__int64 __fastcall SkciValidateDynamicCodePages(
        __int64 pTargetCode,
        __int64 TargetByteCount,
        __int64 pHash,
        unsigned __int64 HashByteCount)
{
  __int64 result; // rax

  result = CiValidateFullImagePages(pTargetCode, TargetByteCount, 0x800E, pHash, HashByteCount >> 5, 0x20, 0x20, 0x20);// Only outputs 0 or 0xC0000428
  if ( (int)result >= 0 )
    return 0x12C;
  return result;                                // Only outputs 0x12C or 0xC0000428
}
```

## CiValidateFullImagePages

```c
__int64 __fastcall CiValidateFullImagePages(
        __int64 pTargetCode,
        unsigned __int64 TargetByteCount,
        __int64 HashType,
        __int64 pHashData,
        unsigned __int64 HashCount,
        unsigned int CompareSize,
        unsigned int a7,
        unsigned int CompareOffset)
{
  __int64 pParallelHashingContext; // rbx
  unsigned __int64 TargetPageCount; // rdi
  __int64 result; // rax
  unsigned int v14; // r8d
  unsigned int CurrentComparisonPageCount; // esi
  __int64 v16; // rax
  __int64 v17; // rdx
  char *pGeneratedHashOutput; // r14
  unsigned int i; // ebp
  char GeneratedHashOutput; // [rsp+40h] [rbp-88h] BYREF

  pParallelHashingContext = 0;
  TargetPageCount = TargetByteCount >> 0xC;
  if ( TargetByteCount >> 0xC > HashCount )
    return 0xC0000428LL;
  if ( TargetPageCount > 1 && (_DWORD)HashType == 0x800C )
    pParallelHashingContext = CipAcquireParallelHashingContext();
LABEL_6:
  if ( TargetPageCount )
  {
    if ( pParallelHashingContext && TargetPageCount > 1 )// Only SHA256 can generate hash of maximum 8 pages each time, 
                                                // other hash will generate the hash and compare one by one
    {
      v14 = 0;
      if ( TargetPageCount >= 8 )
        CurrentComparisonPageCount = 8;
      else
        CurrentComparisonPageCount = TargetPageCount;
      do
      {
        v16 = 0xALL * v14;
        v17 = pTargetCode + (v14++ << 0xC);
        *(_QWORD *)(pParallelHashingContext + 8 * v16 + 0x510) = v17;
      }
      while ( v14 < CurrentComparisonPageCount );
      SymCryptParallelSha256Process(
        pParallelHashingContext + 0x100,
        CurrentComparisonPageCount,
        pParallelHashingContext + 0x500,
        2 * CurrentComparisonPageCount,
        pParallelHashingContext + 0x780,
        0xB6E);
      pGeneratedHashOutput = (char *)pParallelHashingContext;
    }
    else
    {
      CurrentComparisonPageCount = 1;
      HashKComputeMemoryHash(HashType, pTargetCode);
      pGeneratedHashOutput = &GeneratedHashOutput;
    }
    for ( i = 0; ; ++i )
    {
      if ( i >= CurrentComparisonPageCount )    // Loop ends, all equal
      {
        TargetPageCount -= CurrentComparisonPageCount;
        pTargetCode += CurrentComparisonPageCount << 0xC;
        goto LABEL_6;                           // Jump above, go to the next page of target memory if exist
      }
      if ( memcmp_0(&pGeneratedHashOutput[CompareOffset], (const void *)pHashData, CompareSize) )
        break;                                  // not equal, outputs 0xC0000428
      pGeneratedHashOutput += 0x20;
      pHashData += a7;
    }
    result = 0xC0000428LL;
  }
  else
  {
    result = 0;                                 // All pages validated
  }
  if ( pParallelHashingContext )
    _interlockedbittestandset(
      &g_CiParallelPageHashContextsAvailableMask,
      0xD410E5CF * ((pParallelHashingContext - g_CiParallelPageHashContexts) >> 4));
  return result;
}
```
