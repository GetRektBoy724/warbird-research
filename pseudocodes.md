# Pseudocodes

You can check the pseudocodes that generated by IDA and cleaned up as good as Im able to.

## _PAGEWX_PREPARATION_INFO

```c
struct _PAGEWX_PREPARATION_INFO
{
  DWORD64 NewMdlVa;
  DWORD64 NewMdlLength;
  DWORD64 MdlVaToMappingOffset;
  DWORD IsEncrypt;
  DWORD Unknown5;
  DWORD64 PAGEwxN;
  DWORD64 NewMdl;
  DWORD64 Mdl;
  DWORD IsNewMdlLocked;
  DWORD Unknown9;
  DWORD64 MdlVaOrSectionVa;
  DWORD64 LockedMappedMdlVa;
  DWORD64 MdlLength;
  DWORD64 PAGEwxIndex;
};
```

## WarbirdDecryptSection

```c
__int64 __fastcall WarbirdDecryptSection(unsigned int *DecryptionData1, int *DecryptionData2)
{
  int result; // edi
  int decryptionCount; // eax

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 )
  {
    if ( decryptionCount != -1 )
      *DecryptionData2 = decryptionCount + 1;
  }
  else
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 0);
    if ( result >= 0 )
      *DecryptionData2 = 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return (unsigned int)result;
}
```

## WarbirdReencryptSection

```c
__int64 __fastcall WarbirdReencryptSection(_DWORD *DecryptionData1, int *DecryptionData2)
{
  int decryptionCount; // ecx
  unsigned int result; // eax MAPDST

  result = 0;
  if ( (*DecryptionData1 & 1) == 0 )
    return 0;
  ExAcquireFastMutex(&WarbirdMutex);
  decryptionCount = *DecryptionData2;
  if ( *DecryptionData2 == 1 )
  {
    result = WarbirdEncryptDecryptSection((__int64)DecryptionData1, (__int64)DecryptionData2, 1u);
    *DecryptionData2 = 0;
  }
  else if ( (unsigned int)(decryptionCount - 1) <= 0xFFFFFFFD )
  {
    *DecryptionData2 = decryptionCount - 1;
  }
  ExReleaseFastMutex(&WarbirdMutex);
  return result;
}
```

## WarbirdEncryptDecryptSection
```c
__int64 __fastcall WarbirdEncryptDecryptSection(__int64 DecryptionData1, __int64 DecryptionData2, DWORD IsEncrypt)
{
  int result; // esi
  unsigned int i; // r14d
  unsigned __int64 NewMdlVaLength2; // r8
  DWORD64 NewMdlVa; // rbx
  DWORD64 NewMdlVaEnd; // r13
  unsigned __int64 v10; // r9
  unsigned int v11; // edx
  _PAGEWX_PREPARATION_INFO SectionInfo; // [rsp+40h] [rbp-39h] BYREF
  unsigned int NewMdlVaLength; // [rsp+E0h] [rbp+67h] BYREF

  SectionInfo.PAGEwxN = (unsigned __int8)((unsigned __int64)*(unsigned int *)DecryptionData1 >> 1);
  memset(&SectionInfo, 0, 24);
  result = 0;
  SectionInfo.IsEncrypt = IsEncrypt;
  memset(&SectionInfo.NewMdl, 0, 20);
  memset(&SectionInfo.MdlVaOrSectionVa, 0, 32);
  if ( !(unsigned int)WarbirdPrepareSectionForModification(&SectionInfo) )
    return 0x80070005LL;
  i = 0;
  if ( *(_WORD *)(DecryptionData1 + 80) )
  {
    do
    {
      if ( result < 0 )
        break;
      NewMdlVa = 0x180000000LL + ((*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF);
      NewMdlVaLength = *(_DWORD *)(DecryptionData1 + 8LL * i + 88) & 0xFFFFFFF;
      NewMdlVaLength2 = NewMdlVaLength;
      NewMdlVaEnd = NewMdlVa + NewMdlVaLength;
      if ( NewMdlVa < SectionInfo.NewMdlVa || NewMdlVaEnd >= SectionInfo.NewMdlLength + SectionInfo.NewMdlVa )
      {
        WarbirdCleanUpMdl(&SectionInfo);
        SectionInfo.NewMdlVa = NewMdlVa & 0xFFFFFFFFFFFFF000uLL;
        SectionInfo.NewMdlLength = ((NewMdlVaEnd + 4095) & 0xFFFFFFFFFFFFF000uLL) - (NewMdlVa & 0xFFFFFFFFFFFFF000uLL);
        if ( !(unsigned int)WarbirdSetupNewMdl(&SectionInfo) )
          goto LABEL_19;
        NewMdlVaLength2 = NewMdlVaLength;
      }
      if ( NewMdlVa + SectionInfo.MdlVaToMappingOffset )
      {
        v10 = *(_QWORD *)(DecryptionData1 + 8);
        v11 = *(unsigned __int16 *)(DecryptionData2 + 2LL * i + 4);
        if ( IsEncrypt )
        {
          if ( (v11 & 0x8000u) == 0 )
          {
            LOBYTE(NewMdlVaLength) = 0;
            WarbirdFeistelEncrypt(
              (char *)NewMdlVa,
              (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
              NewMdlVaLength2,
              v10,
              (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
              &NewMdlVaLength);
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4) = NewMdlVaLength;
            *(_WORD *)(DecryptionData2 + 2LL * i + 4) |= 0x8000u;
          }
        }
        else if ( (v11 & 0x8000) != 0 )
        {
          LOWORD(v11) = ~(_WORD)v11;
          WarbirdFeistelDecrypt(
            (_BYTE *)NewMdlVa,
            (_BYTE *)(NewMdlVa + SectionInfo.MdlVaToMappingOffset),
            NewMdlVaLength2,
            v10,
            (*(_DWORD *)(DecryptionData1 + 8LL * i + 84) >> 1) & 0xFFFFFFF,
            *(_BYTE *)(DecryptionData2 + 2LL * i + 4),
            (v11 >> 8) & 1);
          *(_WORD *)(DecryptionData2 + 2LL * i + 4) = *(_WORD *)(DecryptionData2 + 2LL * i + 4) & 0x7EFF | 0x100;
        }
        goto LABEL_10;
      }
LABEL_19:
      result = 0x8007000E;
LABEL_10:
      ++i;
    }
    while ( i < (unsigned __int16)*(_DWORD *)(DecryptionData1 + 80) );
  }
  WarbirdCleanUpMdl(&SectionInfo);
  if ( !WarbirdFinishSectionModification(&SectionInfo) )
    return 0x8007000E;
  return (unsigned int)result;
}
```

## WarbirdPrepareSectionForModification

```c
__int64 __fastcall WarbirdPrepareSectionForModification(_PAGEWX_PREPARATION_INFO *pSectionInfo)
{
  __int64 PAGEwxIndex; // r8
  unsigned int *PAGEwxN; // r9
  void *pTargetRVA; // rcx
  DWORD64 TargetLength; // rax
  struct _MDL *pTargetMdl; // rax
  PMDL *ppSectionMdl; // rsi
  PVOID LockedDataSectionHandle; // r14
  PMDL pMdl; // r10
  PVOID MappedSystemVa; // rax
  DWORD64 *p_Mdl; // rdi
  unsigned int IsSucceed; // [rsp+30h] [rbp-28h]

  IsSucceed = 1;
  PAGEwxIndex = 0;
  PAGEwxN = &StoredPAGEwxData[0].PAGEwxN;
  do
  {
    if ( *PAGEwxN == pSectionInfo->PAGEwxN )
      break;
    PAGEwxIndex = (unsigned int)(PAGEwxIndex + 1);
    PAGEwxN += 5;
  }
  while ( (unsigned int)PAGEwxIndex < 6 );
  if ( (_DWORD)PAGEwxIndex != 6 )
  {
    pSectionInfo->PAGEwxIndex = (unsigned int)PAGEwxIndex;
    pTargetRVA = (void *)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA);
    pSectionInfo->MdlVaOrSectionVa = (DWORD64)pTargetRVA;
    TargetLength = StoredPAGEwxData[PAGEwxIndex].PageCount << 12;
    pSectionInfo->MdlLength = TargetLength;
    pTargetMdl = IoAllocateMdl(pTargetRVA, TargetLength, 0, 0, 0);
    ppSectionMdl = (PMDL *)&pSectionInfo->Mdl;
    pSectionInfo->Mdl = (DWORD64)pTargetMdl;
    if ( pTargetMdl )
    {
      MmProbeAndLockPages(pTargetMdl, 0, IoModifyAccess);
      if ( (int)MmChangeImageProtection(
                  *ppSectionMdl,
                  (unsigned int)PAGEwxHashRVA
                + 32LL * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].HashIndex
                + 0x180000020LL,
                  32 * StoredPAGEwxData[pSectionInfo->PAGEwxIndex].PageCount,
                  2) < 0 )
      {
        MmUnlockPages(*ppSectionMdl);
        IsSucceed = 0;
      }
      else
      {
        LockedDataSectionHandle = 0;
        if ( !pSectionInfo->IsEncrypt )
        {
          LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL
                                                                   + StoredPAGEwxData[pSectionInfo->PAGEwxIndex].RVA));
          ++LockedPagableDataSectionCount;
        }
        pMdl = *ppSectionMdl;
        if ( ((*ppSectionMdl)->MdlFlags & 5) != 0 )
          MappedSystemVa = pMdl->MappedSystemVa;
        else
          MappedSystemVa = MmMapLockedPagesSpecifyCache(pMdl, 0, MmCached, 0, 0, 0x40000020u);
        pSectionInfo->LockedMappedMdlVa = (DWORD64)MappedSystemVa;
        if ( !MappedSystemVa )                  // If failed
        {
          if ( !pSectionInfo->IsEncrypt && LockedDataSectionHandle )
          {
            MmUnlockPagableImageSection(LockedDataSectionHandle);
            ++UnlockedPagableImageSectionCount;
          }
          WarbirdChangeImageProtection(pSectionInfo, 0);
          MmUnlockPages(*ppSectionMdl);
          IsSucceed = 0;
          ++qword_1800DAEB8;
        }
      }
      if ( IsSucceed )
        return IsSucceed;
      p_Mdl = &pSectionInfo->Mdl;
    }
    else
    {
      IsSucceed = 0;
      p_Mdl = &pSectionInfo->Mdl;
    }
    if ( *ppSectionMdl )
    {
      IoFreeMdl(*ppSectionMdl);
      *p_Mdl = 0;
    }
    return IsSucceed;
  }
  return 1;
}
```

## WarbirdFinishSectionModification

```c
_BOOL8 __fastcall WarbirdFinishSectionModification(_PAGEWX_PREPARATION_INFO *pPagesInfo)
{
  struct _MDL *pSectionMdl; // rdx
  BOOL IsSucceed; // ebp
  DWORD64 PAGEwxIndex; // rax
  PVOID LockedDataSectionHandle; // rax MAPDST
  _BOOL8 result; // rax
  __int64 HashRVA; // r14
  unsigned int PageCount; // ebx
  __int64 HashIndex; // r15
  void *LockedMappedMdlVa; // rcx

  pSectionMdl = (struct _MDL *)pPagesInfo->Mdl;
  IsSucceed = 1;
  if ( pSectionMdl )
  {
    PAGEwxIndex = pPagesInfo->PAGEwxIndex;
    if ( pPagesInfo->IsEncrypt )
    {
      LockedDataSectionHandle = MmLockPagableDataSection((PVOID)(0x180000000LL + StoredPAGEwxData[PAGEwxIndex].RVA));
      ++LockedPagableDataSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
      MmUnlockPagableImageSection(LockedDataSectionHandle);
      ++UnlockedPagableImageSectionCount;
    }
    else
    {
      HashRVA = (unsigned int)PAGEwxHashRVA;
      PageCount = StoredPAGEwxData[PAGEwxIndex].PageCount;
      HashIndex = StoredPAGEwxData[PAGEwxIndex].HashIndex;
      LockedMappedMdlVa = (void *)pPagesInfo->LockedMappedMdlVa;
      if ( LockedMappedMdlVa )
      {
        MmUnmapLockedPages(LockedMappedMdlVa, pSectionMdl);
        pPagesInfo->LockedMappedMdlVa = 0;
      }
      IsSucceed = (int)MmChangeImageProtection(
                         pPagesInfo->Mdl,
                         HashRVA + 32 * HashIndex + 0x180000020LL,
                         32 * PageCount,
                         1) >= 0;
    }
    MmUnlockPages((PMDL)pPagesInfo->Mdl);
    IoFreeMdl((PMDL)pPagesInfo->Mdl);
    pPagesInfo->Mdl = 0;
  }
  pPagesInfo->MdlVaOrSectionVa = 0;
  result = IsSucceed;
  pPagesInfo->LockedMappedMdlVa = 0;
  pPagesInfo->MdlLength = 0;
  pPagesInfo->PAGEwxIndex = 0;
  pPagesInfo->MdlVaToMappingOffset = 0;
  return result;
}
```

## MmChangeImageProtection

```c
__int64 __fastcall MmChangeImageProtection(
        _MDL *pTargetMdl,
        unsigned __int64 pHash,
        __int64 HashSize,
        int ProtectionFlags)
{
  int HashSize2; // r13d
  ULONG TargetMdlByteCount; // ebp
  unsigned int TargetMdlPageCount; // ebp
  _KLDR_DATA_TABLE_ENTRY *pModuleTableEntry; // rax MAPDST
  int output; // ebx
  char *TargetModuleBase; // r8
  unsigned __int64 pHashEnd; // rdx
  char *TargetModuleEnd; // rax
  unsigned int Flags; // eax
  unsigned __int64 *pTargetMdlPfnArray; // r15
  __int64 i; // r14
  _MMPFN *pCurrentPfnDatabaseEntry; // rcx
  unsigned int v21; // r9d
  __int64 v22; // rdi
  _DWORD IsLdrTableLocked[14]; // [rsp+20h] [rbp-38h] BYREF

  IsLdrTableLocked[0] = 0;
  if ( (unsigned int)(ProtectionFlags - 1) > 1 )// Only accepts ProtectionFlag either 1 or 2
    return 0xC000000DLL;
  HashSize2 = HashSize;
  if ( HashSize != (unsigned int)HashSize )
    return 0xC000000DLL;
  if ( (pTargetMdl->MdlFlags & 7) != 2 )
    return 0xC000000DLL;
  if ( pTargetMdl->ByteOffset )
    return 0xC000000DLL;
  TargetMdlByteCount = pTargetMdl->ByteCount;
  if ( (TargetMdlByteCount & 0xFFF) != 0 )
    return 0xC000000DLL;
  TargetMdlPageCount = TargetMdlByteCount >> 0xC;
  pModuleTableEntry = (_KLDR_DATA_TABLE_ENTRY *)MiLockLoadedDataTableEntryIfNecessary(
                                                  (__int64)pTargetMdl->StartVa,
                                                  IsLdrTableLocked);
  if ( pModuleTableEntry )
  {
    TargetModuleBase = (char *)pModuleTableEntry->DllBase;
    pHashEnd = pHash + HashSize;
    TargetModuleEnd = &TargetModuleBase[pModuleTableEntry->SizeOfImage];
    if ( (char *)pTargetMdl->StartVa + pTargetMdl->ByteCount > TargetModuleEnd
      || pHash < (unsigned __int64)TargetModuleBase
      || pHashEnd > (unsigned __int64)TargetModuleEnd
      || pHashEnd - 1 < pHash )
    {
      output = 0xC0000018;
    }
    else
    {
      Flags = pModuleTableEntry->Flags;
      if ( (Flags & 0x80000) != 0 )
      {
        output = 0xC0000043;
      }
      else
      {
        output = 0;
        pModuleTableEntry->Flags = Flags | 0x80000;
        if ( (unsigned int)MI_IS_PHYSICAL_ADDRESS((unsigned __int64)TargetModuleBase) )
        {
LABEL_34:
          output = 0xC0000018;
        }
        else
        {
          pTargetMdlPfnArray = (unsigned __int64 *)&pTargetMdl[1];
          for ( i = 0; (unsigned int)i < TargetMdlPageCount; i = (unsigned int)(i + 1) )
          {
            pCurrentPfnDatabaseEntry = (_MMPFN *)(0x30 * pTargetMdlPfnArray[i] - 0x220000000000LL);// Get PFN database (MMPFN)
            if ( (pCurrentPfnDatabaseEntry->u4.EntireField & 0x8000000000000000uLL) != 0LL )// Checks if PrototypePte flag is set.
              goto LABEL_34;
            if ( (MiGetPagePrivilege((ULONG_PTR)pCurrentPfnDatabaseEntry) & 0x40) != 0 )
            {
              output = 0xC0000045;
              goto LABEL_24;
            }
          }
          MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, 1u);// Protection set to writable
          if ( ProtectionFlags == 1 )
          {
            if ( (MiFlags & 0x4000) == 0
              || (output = VslValidateDynamicCodePages((__int64)pTargetMdl, pHash, HashSize2), output >= 0) )
            {
              v21 = 3;
              if ( (MiFlags & 0x8000) != 0 && output == 0x12C )
                v21 = 0x13;
              MiSetImageProtection(pModuleTableEntry, (unsigned __int64)pTargetMdl->StartVa, pTargetMdl->ByteCount, v21);// Protection set to executable
              output = 0;
            }
          }
          else if ( (MiFlags & 0x8000) != 0 && TargetMdlPageCount )
          {
            v22 = TargetMdlPageCount;
            do
            {
              MiClearPfnImageVerified(0x30 * *pTargetMdlPfnArray++ - 0x220000000000LL, 9);
              --v22;
            }
            while ( v22 );
          }
        }
LABEL_24:
        pModuleTableEntry->Flags &= ~0x80000u;
      }
    }
    if ( IsLdrTableLocked[0] )
      MmUnlockLoadedDataTableEntry(pModuleTableEntry);
  }
  else
  {
    return 0xC0000225;
  }
  return (unsigned int)output;
}
```